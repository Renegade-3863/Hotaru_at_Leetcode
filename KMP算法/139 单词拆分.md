## 139 单词拆分
#### 题目描述如下:
> 给你一个字符串 s 和一个字符串列表 wordDict 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 s 则返回 true。

> 注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

- 本题是一道非常好的字符串类练习题目, 基本可以说是一道题目囊括了字符串匹配以及哈希表相关的知识, 同时也具有一定程度的细节关注, 个人认为是一道非常合适的面试题目

- 基本思路很好理解, 对于每个单词, 我们找出其可以**置入原串中的位置**(首元素的下标)(这部分可以使用KMP, Rabin-Karp滚动哈希算法等实现), 之后我们就获取到了字典中每一个单词可以填入原串的位置信息, 之后只需要遍历一次原串所有的下标, 同时根据每个下标可以填入的字符串的长度更新可以组合出来的字符串长度, 最后只需要判断对于原串长度的字符串能否组合成功即可

**KMP算法回顾**:
    
- KMP算法的命名是根据三个人名字的首字母(Knuth, Morris, Pratt)组成
- 基本是最优的字符串匹配算法(O(n)线性时间, 最大化了字符信息的利用率, 没有重复获取信息)
- 基本思想为前缀计算, 使用一个前缀数组next记录前推信息
- 人话: 假设模式串为p, 原串为s, 则若 p[j] != s[i], 那么我们前推模式串, 用 p[next[j]] 和 s[i] 继续进行比较。如果 next[j] == -1, 那么我们将模式串前推一位, 继续用首位 (p[0]) 和 s[i+1] 进行匹配。
- KMP算法的精髓在于前缀数组的计算和前缀数组的信息优化。 
- 具体的原理比较晦涩难懂, 我们在这里不用大段文字赘述其原理, 先用一个具体例子分析一下原理:

![图片](https://github.com/Renegade-3863/Hotaru_at_Leetcode/blob/main/Pictures/question_139.jpg)
``` C++
class Solution {
public:
    vector<int> next;
    void get_next(string needle, vector<int>& next) {
        int k = -1, j = 0;
        next[0] = -1;
        int n = needle.size();
        while(j < n) {
            if(k == -1 || needle[j] == needle[k]) {
                ++k; ++j;
                if(j < n) {
                    if(needle[j] == needle[k]) next[j] = next[k];
                    else next[j] = k;
                }
            }
            else k = next[k];
        }
    }
    int strStr(string haystack, string needle) {
        next.resize(needle.size());
        get_next(needle, next);
        int i = 0, j = 0;
        int m = haystack.size(), n = needle.size();
        while(i < m && j < n) {
            if(j == -1 || haystack[i] == needle[j]) {
                ++j; ++i;
            }
            else j = next[j];
        }
        if(j == n)
            return i-n;
        return -1;
    }
};
```
