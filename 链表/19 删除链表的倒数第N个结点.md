## 19 删除链表的倒数第N个结点

### 题目描述如下:

> 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。

### 可以说是想通了非常简单, 想不通就非常难的一道题

我们先考虑如何删除链表的第N个结点, 相信大家在数据结构类的课程中都用C语言实现过这一算法:

> 用一个前驱指针域记录遍历结点的前驱结点, 遍历结点右移N次指向要被删除的结点, 前驱结点同步移动至要被删除的结点的前驱结点, 之后进行删除操作即可

此题难点在于, 给定的链表是一个单链表, 不含前驱结点域, 很多同学(比如我一开始也是)就被正向删除结点的算法固化了思维, 困在了从头部用一个指针遍历这一想法的背景中。

其实可以换个角度, 既然一个指针无法提供足够的相对位置信息, 那么我们是否可以尝试多加一个指针呢? 

多加一个指针干嘛呢? 补足我们之前缺少的信息: 链表尾结点的位置！

所以我们可以进行这样的处理:

预设两个指针: 同时指向链表的头结点, 之后将其中一个向后移动N步, 这样我们相当于获得了两个个距离为N的结点在链表中的信息。

之后的思路就很简单了, 同步右移这两个结点, 当靠右的那一个指针移动到了链表的尾部, 那么前面的那一个不就指向了倒数第N个结点吗！！！

同样, 为了处理要删除的是头结点的情况, 可以预设一个哨兵结点dummy, 不过作者本人不太喜欢这种处理方式, 所以实现中就把这种情况单独考虑了

### 代码实现如下:

```C++
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* first = head, *second = head;
        // 将second移动到first后面第n个
        while(n--) second = second->next;
        ListNode* pre = nullptr;
        // 将second移动至链表结尾(空指针是结尾)
        while(second) { 
            pre = first; 
            first = first->next; 
            second = second->next; 
        }
        // 此时first指向的就是需要被删除的结点, 可以用一个pre指针指向first的前驱结点
        // 如果pre非空,则直接调整指针即可
        if(pre) pre->next = first->next;
        // 否则,说明要删除的是头结点,可以直接调整头结点指向
        else head = first->next;
        // 删除结点
        delete first;
        return head;
    }
};
```