class Solution
{
public:
    int calculate(string s)
    {
        // 计算器的基本实现方法，如果不用逆波兰表达式的话，就是用栈+递归了
        // 我们这样实现这个计算器：
        // 我们用一个栈来记录所有独立的算子，以备最后累加起来求出最后的总和
        // 具体的：
        // 比如要计算 2 - 1 + 2 这个表达式
        // 我们栈中记录的就有 '2', '-1', '2' 三个算子
        // 最后从栈中依次弹出并求和即可
        // 这就要求我们再记录一个 "符号变量" sign，用来记录每个算子前面的符号（即 '+' 号或 '-' 号）
        // 最后，如果遇到了括号，即左括号/右括号，我们就用递归来进入子表达式的求解，求解出来的结果同样和符号一起累计到栈中即可
        // 函数定义为：
        // 从 idx 开始的子部分，直到对应 level 的表达式结束为止（例如遇到了右括号/字符串结尾），我们可以得到的计算结果
        int n = s.size();
        function<int(int&)> subCalculate = [&](int& idx) -> int
        {
            // stk 服务于上面提到的算子记录功能
            stack<int> stk;
            // num 累计当前算子的绝对值，sign 记录算子的符号
            int num = 0, sign = 1, i = idx;
            while(i < n)
            {
                // 每个 s[i] 有不同的可能，我们分开来进行处理
                if(s[i] == '(')
                {
                    // 如果是一个左括号，那么我们遇到了一个新的子表达式，而此时 num 一定是 0，因为左括号前面一定是一个符号
                    idx = i+1;
                    num = subCalculate(idx);
                    // 退出时，我们就结束了一个子表达式的计算，不过由于我们遇到符号才会进行累加，所以这里先不进行栈的累计操作，避免重复
                    i = idx;
                }
                if(s[i] == '+')
                {
                    // 如果是个加号，那么我们就遇到了一个新的算子，把 num 的值累加到 stk 中，包含上符号
                    stk.push(sign*num);
                    sign = 1;
                    num = 0;
                }
                if(s[i] == '-')
                {
                    stk.push(sign*num);
                    sign = -1;
                    num = 0;
                }
                if(isdigit(s[i]))
                {
                    // 如果是一个数字，那么我们累加到 num 中即可
                    num = num*10+(s[i]-'0');
                }
                // 本题不涉及 * 号以及 / 号，所以这里不多进行处理
                if(s[i] == ')')
                {
                    // 如果是个右括号，那么我们可以直接结束循环，到结尾处对栈中元素进行累加
                    idx = i+1;
                    break;
                }
                ++i;
            }
            // 结尾，对 stk 中的元素进行累加
            int ret = 0;
            // 注意，如果上面的循环是正常退出的，不是因为 ')' 退出，那么 num 中还会有未累计的元素，我们需要额外再做一步
            if(num)
            {
                stk.push(sign*num);
            }
            while(!stk.empty())
            {
                ret += stk.top();
                stk.pop();
            }
            return ret;
        };
        int idx = 0;
        return subCalculate(idx);
    }
};