## 8 字符串转换整数

### 题目描述如下:

> 请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。

> 函数 myAtoi(string s) 的算法如下：

> 1. 读入字符串并丢弃无用的前导空格
> 2. 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 
> 3. 如果两者都不存在，则假定结果为正。读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。
> 4. 将前面步骤读入的这些数字转换为整数（即，"123" -> 123， "0032" -> 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。
> 5. 如果整数数超过 32 位有符号整数范围 [−2^31,  2^31 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −2^31 的整数应该被固定为 −2^31 ，大于 2^31 − 1 的整数应该被固定为 2^31 − 1 。
> 6. 返回整数作为最终结果。

### 本题依旧是模拟题,照着题意所说的一步一步对字符串进行模拟即可: O(n)

整型溢出部分的处理方法类似第7题,只是这里每个数字字符转成整型一定是正的,所以在算式中有一点细微差别

### 代码如下:

``` C++
class Solution {
public:
    int myAtoi(string s) {
        // 去掉前导空格
        while(s[0] == ' ') 
            s = s.substr(1);
        int sign = 1;
        int res = 0;
        // 检查第一个字符是正负号还是数字
        if(s[0] == '-')
            sign = -1;
        else if(s[0] == '+')
            sign = 1;
        // 如果是数字则计入值,这一步不可能导致溢出
        else if(isdigit(s[0]))
            res += s[0] - '0';
        // 如果既不是正负号也不是数字,那么这个字符串不可能表示一个合法的数字
        else
            return 0;
        int n = s.size();
        // 遍历余下的字符串
        for(int i = 1; i < n; ++i) {
            // 如果当前字符不是数字,则直接返回转换结果            
            if(!isdigit(s[i]))
                return res;
            // 如果符号为正,则每一步都要判别正溢出
            // res * 10 + s[i] - '0' > INT_MAX
            if(sign == 1 && res > (INT_MAX - sign * (s[i] - '0')) / 10)
                return INT_MAX;
            // 如果符号为负,则每一步都要判别负溢出
            else if(sign == -1 && res < (INT_MIN - sign * (s[i] - '0')) / 10)
                return INT_MIN;
            res = res * 10 + sign * (s[i] - '0');
        }
        // 原串没有非数字后缀,结果在这一步返回
        return res;
    }
};

```