#include "Solution.h"

int Leetcode201_300::Solution::lengthOfLIS(vector<int>& nums)
{
    // 本题最简单的方案是利用动态规划
    // 可以自行尝试，不难发现传统的动态规划在本题只能获得最好 O(n^2) 的时间效率
    // 这里就不写那种方案了，直接上贪心 (因为这题太经典了，很多公司都很爱考，建议最好是弄明白最优的贪心解法)
    // 我们定义一个数组 dp (名字不要介意，虽然叫 DP，但它代表的含义并不是动态规划的子问题)
    // 这个数组的含义是：
    // 当前状态下，我们已经知道的最长的，并且结尾值最小的递增子序列的结尾值
    // 理解：
    // 举个例子，比如我们在循环中遍历到 nums 的下标 i
    // 那么 dp 中存储的就是：(注意，这里的 k 一定是不大于 i-1 的)
    // 长度为 1 的，并且结尾值最小的递增子序列的结尾值
    // 长度为 2 的，并且结尾值最小的递增子序列的结尾值
    // ...
    // 长度为 k 的，并且结尾值最小的递增子序列的结尾值
    // 之后，考虑如何根据 nums[i] 对 dp 进行更新
    // 因为所有位置上的元素都是基于 nums[i] 左侧部分数组进行更新的，所以我们可以保证 nums[i] 可以接到任何一个元素后面
    // 之后，考虑应该接到哪，以及怎么接
    // 因为我们要做的事是找出最长的递增子序列
    // 那么最好的情况显然是：我们可以把这个 nums[i] 接到长度为 k 的那个子序列后面，构成一个新的，长度为 k+1 的子序列，nums[i] 做为新的结尾值
    // 但这并不总是能够实现
    // 因为当前 nums[i] 可能并不大于这个长度为 k 的，结尾值最小的子序列的结尾值
    // 重新解释一遍上面这句话
    // 我们 dp 数组的定义是：如果存在长度为 k 的递增子序列，那么我们的 dp 数组要保存的是所有长度为 k 的递增子序列中，结尾值最小的那一个子序列的结尾值
    // 那么我们不难发现：如果 nums[i] 连这个最小的结果都无法越过，那么它肯定就不能完成：尾接构成一个长度为 k+1 的递增子序列 这个任务了
    // 不过即便它不能完成这个最终目标，它依然可以对 dp 数组造成影响
    // 基于我们的定义，如果 nums[i] 从左到右第一次不大于 dp 数组已有元素中的某一个元素(设下标为 j)
    // 那么我们显然需要更新这个长度的子序列的最小结尾值，因为前面所有下标为 dp[0..j-1] 的结尾元素都是小于 nums[i] 的
    // 也就意味着，当前这个长度为 j+1 的子序列的最小结尾值可以更新为 nums[i] 了
    // 至于下标 j 以后的位置，我们都没必要更新，因为 nums[i] 只能作用于长度为 j+1 的子序列，后面长度更长的子序列的结尾值一定是无法更新的
    // 上面这句话的底气是：
    // 我们知道，dp[j] 这个元素是长度为 j+1 的递增子序列最小的结尾值
    // 那么所有长度大于 j+1 的子序列，它们的倒数第二个元素的值不可能比 dp[j] 更小，而 nums[i] 甚至是不大于 dp[j] 的，那么我们根本没法更新后续的最小结尾值，因为那样会破坏递增性质
    // 说了一大堆，现在我们应该发现，本质变成了一种类似二分查找的过程
    // 在代码中慢慢看逻辑吧。。
    // dp 定义见上面解释
    vector<int> dp;
    int n = nums.size();
    for(int i = 0; i < n; ++i)
    {
        int len = dp.size();
        // 记录 dp 数组中第一个不小于 nums[i] 的元素下标，初始值为 len
        int k = len;
        // 这里使用二分查找
        int left = 0, right = len-1;
        while(left <= right)
        {
            int mid = ((right-left)>>1)+left;
            if(dp[mid] >= nums[i])
            {
                k = mid;
                right = mid-1;
            }
            else
            {
                left = mid+1;
            }
        }
        if(k == len)
        {
            dp.push_back(nums[i]);
        }
        else
        {
            dp[k] = nums[i];
        }
    }
    return dp.size();
}