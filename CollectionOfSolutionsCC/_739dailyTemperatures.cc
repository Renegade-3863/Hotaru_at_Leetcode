#include "Solution.h"

vector<int> Leetcode701_800::Soltuion::dailyTemperatures(vector<int>& temperatures)
{
    // 暴力的 O(n^2) 方法就不写了，有点侮辱大家的智商
    // 我们考虑如何优化查找的时间复杂度
    // 我们可以反过来思考这个问题：
    // 首先，对于最右侧的元素，也就是最后一天的温度来说
    // 因为没有后续的天数了，它的结果一定是 0
    // 之后，我们可以保存这一天的温度值，在一个数据结构中（其实应该能猜到要用栈了）
    // 之后，对于左侧的每一个数据，我们进行下面的处理：
    // 检查栈中的顶端元素，它是栈中最小的那个元素的下标
    // 如果栈顶这个最小的元素下标都是大于当前温度的
    // 那么我们不用做任何处理，直接将当前元素压入栈中，同时根据栈顶这个下标和当前元素的下标更新答案数组
    // 而如果栈顶下标的元素小于当前元素，那么当前元素会隔断栈顶这个更小的元素，换句话说，更左侧的元素是看不到这个栈顶元素的
    // 所以我们可以直接把这个栈顶元素弹出（注意：它也不满足条件了）
    // 持续这种弹出操作，直到栈为空或者满足了第一种可能为止即可
    // 用于操作的单调栈
    stack<int> stk;
    // 答案数组
    int n = temperatures.size();
    vector<int> res(n, 0);
    // 我们从最后一个元素开始遍历即可
    for(int i = n-1; i >= 0; --i)
    {
        // 检查栈顶元素
        while(!stk.empty() && temperatures[i] >= temperatures[stk.top()])
        {
            // 根据上面分析，我们需要弹出栈顶元素
            stk.pop();
        }
        // 现在要么 temperatures[i] 是包括它在内后续元素中最大的，要么 temparetures[i] 是栈中最小的元素
        res[i] = stk.empty() ? 0 : stk.top()-i;
        stk.push(i);
    }
    // 返回结果即可
    return res;
}