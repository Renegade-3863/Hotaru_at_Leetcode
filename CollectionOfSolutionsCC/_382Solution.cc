#include "Solution.h"

// 本题是经典的蓄水池算法应用题，我们可以借机会学习一下大数据抽样中最经典的概率学模型
Leetcode301_400::Solution::Solution::Solution(Leetcode301_400::Solution::ListNode* head)
{
    // 最基本的方法，想不到更好的策略来完成 O(1) 的访问
    // 就是把单链表转存到一个数组中
    // 但是这样会使用 O(n) 的额外空间，如果链表很大，我们可能无法一次性在内存中存下这么多数据
    // ListNode* cur = head;
    // while(cur)
    // {
    //     this->memo.push_back(cur->val);
    //     cur = cur->next;
    // }
    // 所以需要考虑蓄水池这种针对超大数据流的抽样算法
    this->memo = head;
}

Leetcode301_400::Solution::Solution::getRandom()
{
    // 蓄水池算法的核心步骤，我们考虑如何真正随机地选取这个数据流中的一个元素
    // 无非就是这个目标：假设一共有 n 个元素，我们要保证每个元素被取到的概率都是 1/n
    // 那么我们假设只看到了链表中的第一个元素，此时我们要随机取一个元素，只能是取这个元素，概率为 1/1 = 1
    // 之后，来了第二个元素，我们要以 1/2 的概率取第二个和第一个元素交换，然后取头部的元素，这样二者被取到的概率都是 1/2
    // 来了第三个元素，我们需要以 1/3 的概率取到每个元素
    // 此时我们以 1/2 的概率取第二个元素和头部元素交换，再以 1/3 的概率取第三个元素和头部元素交换
    // 那么我们选中第一个元素的概率是：第一个元素被选中，并且第二、第三个元素都没有被选中和它交换的概率
    // 也就是：1x(1-1/2)*(1-1/3) = 1/3
    // 我们选中第二个元素的概率是：第一个元素被选中，并且第二个元素本身被选中和它交换，同时第三个元素没有被选中和它交换的概率
    // 也就是：1x(1/2)x(1-1/3) = 1/3
    // 我们选中第三个元素的概率是：第一个元素被选中，并且第三个元素被选中和它交换的概率(因为第三个元素是后判断的，所以第二个元素是否被选中交换没有意义)
    // 也就是：1x(1/3) = 1/3
    // 总结一下基本的证明过程
    // 假设我们一共有 n 个数，我们要从中完全随机地取 k 个数输出
    // 那么我们需要的是：保证每个数被保留到最前面 k 个的集合中的概率都是 k/n
    // 我们先划定数据流的前 k 个元素作为最终结果保存的位置
    // 考虑进行按下面的逻辑进行选择：
    // 对于所有 j > k 的元素，我们以 k/j 的概率选择它与前面 k 个元素组成的序列中的任何一个进行交换
    // 那么对于下标为 j 的元素，我们返回它的概率很明显是 k/j (因为无论与前 k 个中的哪一个交换，最后都会交换到结果集中)
    // 但是还不够，要最终取到下标为 j 的这个元素，我们还需要保证后面的元素不会把它再换出前 k 个的集合
    // 相当于：下标为 j 的元素被选中进行替换 && 下标大于 j 的所有元素都没能替换这个元素 j
    // 对于下标 p > j，它会替换 j 的概率是：k/p * (1/k) = 1/p (注意 j 此时是前 k 个元素中的某一个元素)
    // 那么 j 最终会被保留的概率就是：k/j * (1-1/(j+1)) * (1-1/(j+2)) * ... * (1-1/n) = k/j * j/(j+1) * (j+1)/(j+2) * ... * (n-1)/n
    // = k/n
    // 对于所有 i <= k 的元素，我们返回它的概率等于：之后的所有元素都没有和它进行过交换 (因为只要被换出去了，就不可能被再次换进来)
    // 而这个元素被下标为 p (p > k) 的元素交换的概率是：
    // k/p * 1/k = 1/p
    // 也就是说：不被交换的概率是 1-1/p = (p-1)/p
    // 那么总体的概率就是：
    // 1 * (k/k+1) * (k+1/k+2) * ... * (n-1)/n
    // = k/n
    // 所以所有元素被取到的概率就都是 k/n，符合要求
    // 这个算法正好适合本题单链表 "数据只能访问一次" 的特性
    // 我们直接套用模版即可
    int cnt = 1, ans = 0;
    ListNode* cur = this->memo;
    while(cur)
    {
        if(rand()%cnt == 0)
        {
            ans = cur->val;
        }
        ++cnt;
        cur = cur->next;
    }
    return ans;
}