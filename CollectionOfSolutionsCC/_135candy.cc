#include "solution.h"

int Leetcode101_200::Solution::candy(vector<int>& ratings)
{
    // 本题也是一道较为经典的贪心类问题
    // 先从直观的角度进行考虑
    // 我们似乎可以采取这样较为简单的方式进行糖果的分配：
    // 1. 先给每个孩子一个糖果，这满足了题目给出的第一个要求
    // 为了满足第二个要求，我们可以贪心地分两边进行满足
    // 第一轮循环，保证每个孩子都符合：
    // 1) 如果他的评分比右侧的孩子高，他拿到的糖果数量大于右侧孩子的糖果数，如果不满足，那么就给他糖果。直到他拥有的糖果数多于右侧孩子的糖果数
    // 第二轮循环，保证每个孩子都符合：
    // 2) 如果他的评分比左侧的孩子高，他拿到的糖果数量大于左侧孩子的糖果数，吐过不满足，那么就给他糖果，知道他拥有的糖果数多于左侧孩子的糖果数
    // 证明过程先不急，我们写一下代码
    // 不过需要明确一下遍历的顺序
    // 我们要维护的无非是两个循环不变式
    // 1) 每遍历到一个孩子，检查他的时候，需要保证他右侧的所有孩子都满足：
    // 如果这个孩子的评分比右侧孩子高，那么他拿到的糖果数量比右侧孩子多
    // 否则可能会出现这种情况：
    // 2 2 1 我们原始情况是：1 1 1，先更新了第一个1，把它变为了2，之后更新了第二个1，把它也变为了2，结果前两个孩子拿到的结果还是相同的，不满足要求
    // 2) 类似 1)
    int n = ratings.size();
    // 记录最终答案，至少需要没人给一颗糖果
    int res = n;
    // 用于记录遍历中当前时刻每个孩子拥有的糖果数
    vector<int> eachHolds(n, 1);
    // 第一轮遍历
    for(int i = n-2; i >= 0; --i)
    {
        if(ratings[i] > ratings[i+1] && eachHolds[i] <= eachHolds[i+1])
        {
            // 动态维护信息
            res = res + (eachHolds[i+1]-eachHolds[i]+1);
            eachHolds[i] = eachHolds[i+1]+1;
            eachHolds[i] += (eachHolds[i+1]-eachHolds[i]+1);
        }
    }
    // 执行第二轮遍历
    for(int i = 1; i < n; ++i)
    {
        if(ratings[i] > ratings[i-1] && eachHolds[i] <= eachHolds[i-1])
        {
            // 动态维护信息
            res = res + (eachHolds[i-1]-eachHolds[i]+1);
            eachHolds[i] = eachHolds[i-1]+1;
            eachHolds[i] += (eachHolds[i-1]-eachHolds[i]+1);
        }
    }
    // 返回贪心的结果即可
    return res;
}

// 现在来讨论一下上面的贪心思路为什么是对的，
// 我们采用反证法：假设通过上面这样的方式找出的给糖果结果不是最优的
// 那么它有哪些可能不是最优？
// 1. 假设是第一轮遍历的时候出现了不是最优给法的情况：
// 由于我们第一轮的要求是从右向左遍历，每个评分比右边孩子高的孩子都会得到不少于右边孩子的糖果数，而且我们只会给到当前孩子比右边孩子多1的糖果数，因此理论上不会出现多给的情况
// 2. 假设是第二轮遍历的时候出现了不是最优给法的情况：
// 由于我们第二轮的要求是从左向右遍历，每个评分比左边孩子高的孩子都会得到不少于左边孩子的糖果数，而且我们只会给到当前孩子比左边孩子多1的糖果数
// 问题：如果此时出现了某个孩子比右边孩子多不止1个糖果的情况，此时这个糖果数是最少的吗？
// 确实是最少的，因为即使这个孩子的评分比右边孩子低，如果我们把这个糖果数减少了，就会不满足这个孩子拿到的糖果数多于左边孩子的条件了。
