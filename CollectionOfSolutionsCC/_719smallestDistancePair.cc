#include "Solution.h"

int Leetcode701_800::Soltuion::smallestDistancePair(vector<int>& nums, int k)
{
    // 首先，题目对计算用的数对并没有实际的顺序要求，所以我们可以考虑先对 nums 进行排序
    sort(nums.begin(), nums.end());
    // 排好序之后，我们可以发现一些性质：
    // 首先，相近的数值距离一定相对 (但不是绝对) 较小
    // 比如 [1, 1, 3]
    // 之后考虑如何计算数对之间的关系：
    // 最暴力的方法是
    // 枚举 1，匹配 1, 3
    // 枚举 1，匹配 3
    // 得到结果
    // 上面这样的方法很明显是 O(n^2) 的，题目数据范围限制在了 10^4 数量级，所以这种方法肯定会超时
    // 所以我们需要考虑如何压缩成 O(nlogn) (因为我们排序就用了 O(nlogn)..)
    // 既然要二分，那么我们就需要思考：要二分谁？
    // 这道题里，能二分的东西不多，k 是看起来最像需要被拆的那一个
    // 所以我们尝试拆它
    // 我们尝试寻找二分的上下界，也就是：多大的距离有可能是第 k 小的？
    // 我们不难发现，整个数组中，最大的距离就是 max(nums)-min(nums)
    // 最小距离就是 0
    // 所以我们可以对区间 [0, max(nums)-min(nums)] 进行二分
    
}