#include "Solution.h"

int Leetcode601_700::Soltuion::countBinarySubstrings(string s)
{
    // 举例：
    // 0011 这个子串中，包含一个 01 子串，也满足具有相同数量的连续 1 和 0
    // 所以我们可以用一种类似贪心的策略：
    // 标记一个指针 i
    // 从 i 开始向后找连续的序列，记录它的长度 len
    // 遇到两次转折，就记录 len/2 个连续 1 和 0 的序列
    // 比如示例1:
    // 00110011
    // 从左往右：
    // 0011 : 两次转折
    // 记录 4/2 = 2 子串：0011 和 01 (0011 中间的 01)
    // len/2 之后继续记录：
    // 1100: 遇到一次新的转折
    // 记录 4/2 = 2 子串：1100 和 10 (1100 中间的 10)
    // len/2 之后继续记录：
    // 0011: 遇到一次新的转折
    // 记录 4/2 = 2 子串：0011 和 01 (0011 中间的 01)
    // 最后答案为 6
    // 另一个例子：
    // 101110110
    // 10: 遇到一次转折
    // 记录 2/1 = 1 子串：10 自己
    // len/2 
    // 01
    // 我们模拟上面的逻辑即可，细节上的修改可以看代码内部
    // 第一步：找开头的一串连续元素
    // h1 记录子串前半部分的值，h2 记录后半部分
    // h2 记录 h1 的异或结果
    int h1 = s[0]-'0', h2 = h1^1, len = 1;
    int res = 0, i = 1, n = s.size();
    for(; i < n && s[i]-'0' != h2; ++i)
    {
        ++len;
    }
    // 找完了第一段连续数字，之后每一次遍历 len 个元素就更新一次结果
    int idx = i;
    // 保证每一轮循环开始时，idx 都指向一个新的，不同于 s[idx-1] 的序列开头下标
    while(idx < n)
    {
        int adder = 0;
        // 尝试从 idx 处往后延伸 len 个元素，能延伸的最长部分，就是这部分能添加的结果
        // cout << len << endl;
        for(int k = 0; k < len; ++k)
        {
            if(s[idx+k]-'0' != h2)
            {
                break;
            }
            // 可以记录一次，就累加一次结果
            ++adder;
        }
        // cout << idx << ", " << adder << endl;
        // for 循环结束后，adder 中就记录了可以累加到答案中的结果数量
        res += adder;
        // 我们维护 idx 和 len 的定义
        // 把 len 修改成当前 idx 所在的串的长度
        len = 0;
        while(idx < n && s[idx]-'0' == h2)
        {
            ++len;
            ++idx;
        }
        // 修改 h2 
        h2 = h2^1;
    }
    return res;
}

/*
    100111001
    1
    10
*/