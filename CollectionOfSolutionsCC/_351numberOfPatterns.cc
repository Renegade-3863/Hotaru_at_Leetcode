#include "Solution.h"

int Leetcode301_400::Solution::numberOfPatterns(int m, int n)
{
    // 似乎可以使用暴力递归的算法
    // 我们需要找到的是从某个点出发，路径长度为 k 的所有路径
    // 这可以通过回溯实现
    // 定义一个递归函数
    // dfs(i, j, len) 代表从 (i, j) 出发的，长度为 len 的所有可行的手势长度
    // 注意过程中需要保存一个状态图，用来在不同的状态下执行这些递归函数
    // 记录一个 3x3 的表，代表这张图中目前哪些格子已经被访问过了
    vector<vector<int>> board(3, vector<int>(3, 0));
    // 全局的答案
    int res = 0;
    function<void(int, int, int, const int&)> dfs = [&](int x, int y, int len, const int& tot)
    {
        // 基本情况：len == tot
        // 意思为：该路径覆盖的格子数量已经达到了要求的数量
        // 此时说明我们已经走完了一条可行的的路径，给全局的答案加一即可
        // 不过还需要考虑去重问题，即：我们是否找出了一条前面已经走过了的路径？
        // 首先需要明确一点，不同长度的路径肯定是不会重复的
        // 那么同长度的路径之间会重复吗？
        // 显然是不会的
        // 因为我们每条路径的起点和选择的方向都不一样，稍加思考就能明白不可能发生重复
        if(len == tot)
        {
            ++res;
            return;
        }
        // 对于当前所在的格子，我们可以考虑下一跳要走向的格子位置
        // 思考：如何判断这个下一跳格子是否可行？
        // 我们需要记录的是下一跳到当前格子的两个方向上的距离
        // 我们很明显知道，下一跳可以跳到其它八个格子中的任意一个
        // 我们可以在一个嵌套内循环中进行操作
        for(int i = 0; i < 3; ++i)
        {
            for(int j = 0; j < 3; ++j)
            {
                // 如果下一跳就是当前结点本身，那么直接跳过即可
                if(i == x && j == y)
                {
                    continue;
                }
                if(board[i][j])
                {
                    continue;
                }
                // 否则，是一个不同的下一跳，我们检查其合法性
                int diffx = abs(i-x), diffy = abs(j-y);
                // 有哪些情况是我们可以明确确认就是合法的，不会经过任何中间结点的？
                // 1. "日" 字形 -> (diffx == 1 && diffy == 2) || (diffx == 2 && diffy == 1)
                // 2. "口" 字形 -> (diffx == 1 && diffy == 1)
                // 3. "一" 字形 -> (diffx == 0 && diffy == 1) || (diffx == 1 && diffy == 0)
                // 其它情况，都是会经过中间结点的
                // 4. "田" 字形 -> (diffx == 2 && diffy == 2)
                // 5. "长一" 字形 -> (diffx == 2 && diffy == 0) || (diffx == 0 && diffy == 2)
                // 我们只需要相对应地判断一下这些经过的中间结点是否已经在路径中被访问过了即可
                // "田" 字形
                if(diffx == 2 && diffy == 2 && !board[(i+x)>>1][(j+y)>>1]) 
                {
                    // 中间路过的格子没有访问过，那么我们没法深入递归
                    continue;
                }
                if((diffx == 2 && diffy == 0) && !board[(x+i)>>1][y])
                {
                    // 中间路过的格子没有访问过，那么我们没法深入递归
                    continue;
                }
                if((diffx == 0 && diffy == 2) && !board[x][(y+j)>>1])
                {
                    // 中间路过的格子没有访问过，那么我们没法深入递归
                    continue;
                }
                // 其它情况下，我们都可以对这个下一跳进行递归访问
                // 注意，这里因为有全局数组的存在，我们需要使用回溯的方法进行递归
                // 递归前，标记这个下一跳为访问过
                ++board[i][j];
                dfs(i, j, len+1, tot);
                // 回溯，重置访问过标记
                --board[i][j];
            }
        }
    };
    // 最后，在最外层，我们只需要对每种可行的路径长度，对着整张图循环一次即可找出最终答案
    for(int len = m; len <= n; ++len)
    {
        // cout << len << endl;
        for(int x = 0; x < 3; ++x)
        {
            for(int y = 0; y < 3; ++y)
            {
                // 别忘了先更新访问标记
                ++board[x][y];
                dfs(x, y, 1, len);
                // 重置标记
                --board[x][y];
            }
        }
    }
    // 返回最终结果
    return res;
}