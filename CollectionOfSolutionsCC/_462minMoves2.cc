#include "Solution.h"

int Leetcode401_500::Soltuion::minMoves2(vector<int>& nums)
{
    // 依旧是一道数学题，思路和 I 不大一样
    // 思考：什么情况下，需要的挪动次数最少？
    // 或者说：我们需要归一的那个值大小为多少的时候最合适？
    // 不难想到，首先肯定是 nums 中最大最小值之间的数
    // 那么我们可以确定这个值更具体一些的性质吗？
    // 另一个性质是：这个值到 nums 中所有值的 "距离" 和最小
    // 这就变成了我们之前做过的一道类似的题目：最佳碰头地点
    // 而且是一维的
    // 猜想是整个数组的中位数值就是最后的归一值
    // 猜想总归需要证明，我们考虑如何证明这一点
    // 如果我们对数组进行排序，那么很明显数组中左侧的一半值都是不大于中位数的，右侧的一半值都是不小于中位数的
    // 假设左侧不大于 x 的点到 x 到距离和是 A，右侧不小于 x 的点到 x 到距离和是 B
    // 那么距离和就应该是：
    // A+B
    // 我们现在假设在 x 值(中位数)左侧存在另一个值 x'，可以产生出更小的结果
    // 那么假设 x' 和 x 之间的距离为 d，同时这个变化引起了 k 个点的变动 (从小点变成大点了)
    // 那么依假设有：A-kd + B+(n-k)d < A+B
    // (n-k 是因为不只有这 k 个点的距离变动了，右侧原来的那一半点距离也变动了)
    // 进而推出：n < 2k
    // 也就是说，我们这次修改，引起变动的点的个数多于数组中一半元素个数，但这很明显和我们对原来的值是中位数的假设相矛盾
    // 右侧的证明同理
    // 剩下的就是写代码了
    sort(nums.begin(), nums.end());
    // 提取出中位数
    int n = nums.size(), midL = nums[n-1>>1], midR = nums[n>>1];
    int mid = ((midR-midL)>>1)+midL;
    // 线形遍历即可
    int res = 0;
    for(const auto& num : nums)
    {
        res += abs(num-mid);
    }
    return res;
}