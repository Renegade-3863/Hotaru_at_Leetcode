#include "Solution.h"

// 第一版：DFS 暴力递归
int Leetcode401_500::Soltuion::numberOfArithmeticSlices(vector<int>& nums)
{
    // 本题看了几眼会觉得很像 DP 
    // 想了一下怎么从 DFS 的角度进行递归，不过发现那样的定义方式时间复杂度太高，所以就不费力尝试了，直接从自底向上的 DP 角度来写
    // 定义一个这样的 DP 数组：
    // dp[i][j] 代表：以 nums[i] 结尾，并且等差为 j 的、长度至少为 2 的子序列的个数
    // 从这个角度切入，我们考虑如何进行递推
    // 由于子序列不要求元素相邻，所以我们需要多用一重循环检查下标 i 前面的所有元素
    // 对于每一个 k < i，我们检查：d = nums[i]-nums[k]，这个是 "公差候选值"，之后我们把这对数作为对应的长度至少为 2 的子序列添加到 dp[i][d] 中即可
    // 不过由于题目要求的是 "长度至少为 3 的子序列"，那么我们还需要考虑进行筛查
    // 递推式写出来是这样的：
    // dp[i][d] += dp[k][d]+1(这个1是指 nums[i]-nums[k] == d，式子里的 d 是 dp 更新的因，而不是 dp[i][d] 是 d 的因，注意这一点，这里也是之前说用 DFS 复杂度较高的原因所在)
    // 注意到，上面的递推式里，dp[k][d] 这些序列在添加了 nums[i] 这个新元素后，都满足 "长度至少为 3" 这一要求，而后面这个新加的数据对 (nums[i], nums[k]) 则是不满足条件的 "长度为 2 的子序列"
    // 所以我们实际上只需要统计所有 dp[k][d] 的个数累加和即可得到最终答案
    // 明确了基本的解答流程，我们还有最后一个小细节需要考虑：
    // d 会不会很大？
    // i 的值不会很大，因为它跟数组本身的长度直接关联，而 d 可以非常大，如果用静态数组，会导致我们的空间复杂度非常高
    // 所以我们需要一些空间处理
    // 例如用哈希表代替静态数组进行数据存储
    // 剩下的就是写代码了
    // dp 数组，记录的是：以 nums[i] 结尾，并且公差为 d 的所有子序列的个数
    // 由于公差可以很大，所以这里内部哈希表的键值我们用 long long 类型来存储
    int n = nums.size();
    vector<unordered_map<long long, int>> dp(n); 
    // 双层遍历，i 可以从 1 开始，而不是 0，因为长度合法的序列最短也要为 2
    // 最终的结果值，是所有 dp[k][d] 的累加和
    int res = 0;
    // 对于每一个 nums[i] 进行遍历
    for(int i = 1; i < n; ++i)
    {
        // 对于每一个 nums[i]，对前面的每一个元素进行遍历
        for(int k = 0; k < i; ++k)
        {
            // 计算出公差 d
            // 这里总结出一个小的语言细节：
            // C++ 似乎并不完全通过变量类型声明来决定所有结果的类型(不确定是不是大多数编程语言都是这样)
            // 下面的这条语句，执行的顺序是：
            // 右侧 evaluate nums[i]-nums[k] 的结果
            // 这个结果是一个右值，值的类型受参与运算的两个值，也就是 nums[i] 和 nums[k] 影响
            // 换句话说：由于 nums[i] 和 nums[k] 都是 int 类型，那么算出来的这个右值也默认是 int 型
            // 跟左边声明的，d 的类型 long long 是没有半毛钱关系的
            // 所以我们还必须手动添加一个强制类型转换，把 nums[i], nums[k] 中至少一个转换成 long long 类型，才能达到想要的结果
            // 否则，依然会出现 overflow 警告甚至是错误
            long long d = (long long)nums[i]-nums[k];
            // 进行递推
            res += dp[k][d];
            dp[i][d] += dp[k][d]+1;
        }
    }
    // 计算完成，返回最终结果
    return res;
}