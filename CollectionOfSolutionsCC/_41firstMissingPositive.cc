#include "Solution.h"

int Leetcode1_100::Solution::firstMissingPositive(vector<int>& nums)
{
    // 一种没什么传统技巧的智力题目，需要一些思考
    // 要找缺失的第一个正数，同时限定了这个数组中的元素一定都是正整数
    // 我们从最简单的暴力方法开始
    // 最简单的，使用 O(n) 空间的方法是，使用一个哈希表，记录所有出现过的数字，遍历一遍整个 nums 数组，记录所有出现过的正数
    // 之后使用一个标记变量 res 记录最小的正数，再检查一遍哈希表，如果 res 在哈希表中出现过，那么就给 res 递增1，直到遇到一个 res 在哈希表中没有出现过，就可以返回了
    // 不过这种方案，如果要检查的 nums 数组很大，那么就会导致内存问题，我们需要进行优化
    // 如何优化？
    // 反向考虑：如果这个数组中不存在中间缺失的正数
    // 那么它应该由一个从1开始连续的整数序列，此时结果就是 nums.size()+1
    // 那么，我们考虑如何把这个数组恢复成这种样子
    // 其实比较直接的方法是每遍历到一个数字，就把它交换到它应在的位置上 (本题的特殊数据范围决定了我们这样交换是可行的)
    // 比如一个长度为 5 的数组，那么全连续的正整数应该是 [1, 2, 3, 4, 5]
    // 其中如果 2 不在第二个位置上，我们就可以把2和现在在第二个位置上的元素交换，从而使得 2 在这个位置上即可
    // 而如果遇到一个不在 [1, n] 范围内的元素，说明这个元素就是一个错误的元素，我们可以用这样的元素来标志一个 [1, n] 范围内元素的缺失
    // 使用这种方式，每次交换都会把一个范围内的数据放到它应该在的位置上
    // 全部交换完成后，所有在 [1, n] 范围内的元素都会在正确的位置上，而对应位置上的元素不是应有的元素的这些位置就缺少了对应的正整数
    // 最后考虑一种意外情况：某种 [1, n] 范围内的元素重复出现了多次
    // 此时我们使用 while 循环进行交换可能会导致死循环，因为我们之前把多个重复元素中的一个放到了正确的位置上，因而后面再交换的时候
    // 会发现总有一个重复元素不在正确的位置上，因而会不断地进行交换，此时解决办法也很简单，可以设定另一个退出条件
    // nums[nums[i]-1] == nums[i]
    // 此时说明我们已经把一个正确元素放到了它对应位置上了，这个重复的异位元素就可以当做一个错误元素使用了
    // 思路明确，写代码即可
    int n = nums.size();
    int res = n+1;
    for(int i = 0; i < n; ++i)
    {
        while(nums[i] >= 1 && nums[i] <= n && nums[i] != nums[nums[i]-1])
        {
            swap(nums[i], nums[nums[i]-1]);
        }
    }
    for(int i = 0; i < n; ++i)
    {
        if(nums[i] != i+1)
        {
            res = i+1;
            break;
        }
    }
    return res;
}