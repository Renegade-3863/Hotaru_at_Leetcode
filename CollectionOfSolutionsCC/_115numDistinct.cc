#include "Solution.h"
const int MOD = 100000007;

// 纯暴力 DFS，可以预见的超时
int Leetcode101_200::Solution::numDistinct(string s, string t)
{
    // 不好说，不过这题我的第一反应确实是类似动态规划的那种问题
    // 遇到动态规划问题，我们还是不要马上就去想自底向上的动态规划方程，那样比较反人类
    // 我们先考虑自顶向下的 DFS 方案
    // 定义如下的 DFS 回调函数
    // dfs(s, t, i, j) 代表在 s 的前 i 个字符构成的前缀串中 t 的前 j 个字符构成的前缀串出现的次数
    // 考虑如何进行子问题分解
    // 1. t[j-1] == s[i-1]
    // 此时我们可以考虑两种可能
    // 首先是将 s[i-1] 和 t[j-1] 进行匹配，此时 dfs(s, t, i, j) 就有 dfs(s, t, i-1, j-1) 的成分，即除去这两个匹配的字符，前面的前缀串中对应的出现次数
    // 之后是不用 s[i-1] 和 t[j-1] 进行匹配，此时 dfs(s, t, i, j) 就有 dfs(s, t, i-1, j) 的成分
    // 实际上有人可能会说，应该有很多更小的子问题：
    // 形式为： dfs(s, t, i-k, j) 其中 k 属于 [1, i]
    // 但是，让我们回到定义：dfs(s, t, i, j) 定义就是 "考虑" s 的前 i 个字符组成的子串，"考虑" t 的前 j 个字符组成的子串
    // t 的前 j 个字符组成的子串在 s 的前 i 个字符组成的子串中出现的次数
    // 而由于这个大问题中，有关 t 大部分定义在上面这个含 k 的参数表达式中是不变的，因而我们会发现下面的重叠关系：(这其实就是动态规划所谓的 "重叠子问题")
    // 在我们求解 t 的前 j 个字符组成的子串在 s 的前 i 个字符组成的子串中出现的次数时，这个大的次数一定包含了
    // t 的前 j 个字符组成的子串在 s 的前 i-k 个字符组成的子串中出现的次数 这一子问题的结果
    // 所以，如果重复计算，很显然我们会得到错误的答案！！
    // 2. t[j-1] != s[i-1]
    // 那么此时就只有一种可能了
    // dfs(s, t, i, j) = dfs(s, t, i-1, j)
    // 这样，我们就不难写出初版的自顶向下的 DFS 方案了
    function<int(int, int)> dfs = [&](int i, int j) ->int
    {
        // 设置递归的结束条件
        // 1. i == 0
        // 即 s 部分是空的，此时只有当 j 也等于0的时候，才能得出一种出现可能，其它情况均应该返回0
        if(i == 0)
        {
            return j == 0;
        }
        // 2. j == 0
        // 即 t 部分是空的，此时总有且仅有一种可能(无论 i 为何值)，就是用 s 取出的空串可 t 这个空串进行匹配
        if(j == 0)
        {
            return 1;
        }
        // 一般情况
        // 记录一个返回值
        int ret = 0;
        // 对应情况1
        if(s[i-1] == t[j-1])
        {
            ret += dfs(i-1, j-1);
        }
        // 对应情况2，注意情况1其实是情况2的一种特殊情况，二者可以合并
        ret += dfs(i-1, j);
        return ret;
    };
    // 题目要求我们将结果对 10^9+7 取模，照做
    return dfs(s.size(), t.size()) % MOD;
}

// 第二版：考虑在第一版的基础上加上记忆化，可过
int numDistinctMemo(string s, string t)
{
    // 不好说，不过这题我的第一反应确实是类似动态规划的那种问题
    // 遇到动态规划问题，我们还是不要马上就去想自底向上的动态规划方程，那样比较反人类
    // 我们先考虑自顶向下的 DFS 方案
    // 定义如下的 DFS 回调函数
    // dfs(s, t, i, j) 代表在 s 的前 i 个字符构成的前缀串中 t 的前 j 个字符构成的前缀串出现的次数
    // 考虑如何进行子问题分解
    // 1. t[j-1] == s[i-1]
    // 此时我们可以考虑两种可能
    // 首先是将 s[i-1] 和 t[j-1] 进行匹配，此时 dfs(s, t, i, j) 就有 dfs(s, t, i-1, j-1) 的成分，即除去这两个匹配的字符，前面的前缀串中对应的出现次数
    // 之后是不用 s[i-1] 和 t[j-1] 进行匹配，此时 dfs(s, t, i, j) 就有 dfs(s, t, i-1, j) 的成分
    // 实际上有人可能会说，应该有很多更小的子问题：
    // 形式为： dfs(s, t, i-k, j) 其中 k 属于 [1, i]
    // 但是，让我们回到定义：dfs(s, t, i, j) 定义就是 "考虑" s 的前 i 个字符组成的子串，"考虑" t 的前 j 个字符组成的子串
    // t 的前 j 个字符组成的子串在 s 的前 i 个字符组成的子串中出现的次数
    // 而由于这个大问题中，有关 t 大部分定义在上面这个含 k 的参数表达式中是不变的，因而我们会发现下面的重叠关系：(这其实就是动态规划所谓的 "重叠子问题")
    // 在我们求解 t 的前 j 个字符组成的子串在 s 的前 i 个字符组成的子串中出现的次数时，这个大的次数一定包含了
    // t 的前 j 个字符组成的子串在 s 的前 i-k 个字符组成的子串中出现的次数 这一子问题的结果
    // 所以，如果重复计算，很显然我们会得到错误的答案！！
    // 2. t[j-1] != s[i-1]
    // 那么此时就只有一种可能了
    // dfs(s, t, i, j) = dfs(s, t, i-1, j)
    // 这样，我们就不难写出初版的自顶向下的 DFS 方案了
    // 加上记忆化数组
    // 初始化为-1，代表对应位置的值还没有被填入，我们知道，dfs 函数是用来计算长度的函数，所以它计算出来的值不可能小于0
    vector<vector<int>> memo(s.size()+1, vector<int>(t.size()+1, -1));
    function<int(int, int)> dfs = [&](int i, int j) ->int
    {
        if(memo[i][j] != -1)
        {
            return memo[i][j];
        }
        // 设置递归的结束条件
        // 1. i == 0
        // 即 s 部分是空的，此时只有当 j 也等于0的时候，才能得出一种出现可能，其它情况均应该返回0
        if(i == 0)
        {
            return j == 0;
        }
        // 2. j == 0
        // 即 t 部分是空的，此时总有且仅有一种可能(无论 i 为何值)，就是用 s 取出的空串可 t 这个空串进行匹配
        if(j == 0)
        {
            return 1;
        }
        // 一般情况
        // 记录一个返回值
        int ret = 0;
        // 对应情况1
        if(s[i-1] == t[j-1])
        {
            ret += dfs(i-1, j-1);
        }
        // 对应情况2，注意情况1其实是情况2的一种特殊情况，二者可以合并
        ret += dfs(i-1, j);
        memo[i][j] = ret % MOD;
        return memo[i][j];
    };
    // 题目要求我们将结果对 10^9+7 取模，照做
    return dfs(s.size(), t.size()) % MOD;
}

// 第三版：纯 DP 优化，依据为上面的 DFS 过程
int numDistinctDP(string s, string t)
{
    int m = s.size(), n = t.size();
    // 设立 DP 数组
    vector<vector<int>> dp(m+1, vector<int>(n+1, 0));
    // 初始化边界情况
    dp[0][0] = 1;
    for(int i = 1; i <= m; ++i)
    {
        dp[i][0] = 1;
    }
    // 进行递推即可
    for(int i = 1; i <= m; ++i)
    {
        for(int j = 1; j <= n; ++j)
        {
            // 情况2
            // 根据末尾字符是否相等决定是否要添加情况1
            dp[i][j] = (dp[i-1][j] + (s[i-1] == t[j-1] ? dp[i-1][j-1] : 0)) % MOD;
        }
    }
    // 最后 dp[m][n] 就是答案
    return dp[m][n] % MOD;
}

// 第四版：纯 DP + 滚动数组压缩空间
// 注意到，填表的时候，我们需要的值只有当前位置上方和左上方一格的值，可以根据这个信息进行滚动数组优化
int numDistinctDPOpt(string s, string t)
{
    int m = s.size(), n = t.size();
    // 设立一个一维数组
    vector<int> dp(n+1, 0);
    // 边界情况
    dp[0] = 1;
    // 进行递推
    int upLeft = dp[0];
    for(int i = 1; i <= m; ++i)
    {
        // 每一行的首个元素都是1，这里不用修改 dp[0]
        upLeft = dp[0];
        for(int j = 1; j <= n; ++j)
        {
            int tmp = dp[j];
            dp[j] = (dp[j] + (s[i-1] == t[j-1] ? upLeft : 0)) % MOD;
            upLeft = tmp;
        }
    }
    return dp[n] % MOD;
}