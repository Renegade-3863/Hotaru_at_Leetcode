#include "Solution.h"

int Leetcode201_300::Solution::minMeetingRooms(vector<vector<int>>& intervals)
{
    // 本题可以优先用 DP 的思想来分析
    // 考虑下面的子问题定义：
    // 前 i 个区间所需的最少会议室个数为 dfs(i)
    // 如何定义这个 "前 i 个区间"？
    // 我们不难想到可以通过会议区间的开始时间来判断哪些区间是前 i 个区间
    // 明确了上面的定义方法，我们可以考虑这个子问题是否具有一般的子问题关联性质
    // 先作出下面的假设：我们知道前面所有开过的会议室中，最后一场会议结束时间最早的那一间会议室的结束时间 tmin
    // 那么我们可以给出下面的论断：
    // 对于当前会议 intervals[i-1]
    // 如果有 intervals[i-1].begin >= tmin
    // 那么 dfs(i) = dfs(i-1)
    // 否则，我们就必须新开一间会议室给当前会议
    // dfs(i) = dfs(i-1)+1
    // 分析一下 dfs(i-1)+1 这个式子的正确性
    // 首先，我们知道 intervals[i-1] 前面的所有区间都是开始时间早于 intervals[i-1] 的，那么我们判断是否需要新开一间会议室的基本原则就是：
    // 当前已经开过的所有会议室中，是否存在在 intervals[i-1].begin 时空闲的
    // 而最有可能空闲的会议室是哪一间呢？
    // 很明显就是所有会议室中开会结束时间最早的那一个
    // 如果连这一间会议室的结束时间都不能满足把当前会议安排进来，那么其它结束时间更晚的会议室就更不可能了
    // 那么我们需要做的就只有一件事：动态更新这个结束时间最早的会议室
    // 适合处理这种需求的数据结构我们应该都不陌生：最小优先队列
    // 用一个最小优先队列来保存所有开放的会议室的最晚会议结束时间
    priority_queue<int, vector<int>, greater<int>> minQ;
    // 根本策略就是更新上面这个最小优先队列中的元素
    // 思路写到这里，我们其实可以发现，根本不用 dfs 方案，直接正向遍历就行了。。。
    // 第一步：对原区间数组按开始时间进行排序
    sort(intervals.begin(), intervals.end(), [&](const vector<int>& a, const vector<int>& b) {
        return a[0] < b[0];
    });
    // 第二步，对区间数组进行遍历，过程中动态更新全局的会议室数量，和小顶堆中的元素
    int n = intervals.size();
    // 先添加第一个会议到第一个会议室中
    minQ.push(intervals[0][1]);
    for(int i = 1; i < n; ++i)
    {
        // 检查小顶堆
        // 堆顶堆会议室可以适配当前的会议，那么我们就更新堆顶这个会议室的最晚会议结束时间即可
        if(minQ.top() <= intervals[i][0])
        {
            minQ.pop();
            // 更新的最晚结束时间是当前这个会议的结束时间
            minQ.push(intervals[i][1]);
        }
        // 否则，说明堆顶的会议室也没法适配当前的会议，我们不得已只能新开一间会议室
        else 
        {
            minQ.push(intervals[i][1]);
        }
    }
    // 循环完成，最小优先队列的大小就是我们找到的最优的会议室数量
    return minQ.size();
}

// 思考：上面的思路，是否可以换成对所有会议按结束时间排序？
// 其实是有问题的
// 因为我们添加会议的时候，是按照结束时间升序添加的，所以在我们检查堆顶元素的时候，不能只通过 minQ.top() <= intervals[i][0] 这一个条件来判断：
// 是否可以把当前会议添加到这个会议室中
// 因为可能这个结束时间最早的会议的开始时间反而是晚于 intervals[i] 的，此时我们再把这个会议添加到这个会议室的方法就是完全错误的，因为两个会议是有重合的
// 而按开始时间排序则可以巧妙的规避这个问题：
// 因为 minQ.top() 的这个会议一定是开始时间早于 intervals[i] 的，因而只要 miqQ.top() 本身是晚于 intervals[i][0] 的，那么我们就完全可以进行会议添加
// 至此，问题就完全解决了