class Solution
{
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial)
    {
        int n = graph.size();
        // 比较好的切入点是找图中的联通分量
        // 题目要求的是最终稳定的状态下，被感染的节点数量最少
        // 所以我们就可以检出整张图中所有的联通分量，最好是能知道每个联通分量中的节点数量
        // 无非有几种情况：
        // 1. 有初始感染节点的联通分量中，存在只有一个初始感染节点的，那么这个节点如果被移除的话，就能让整个联通分量不被感染
        // 这种情况下，我们优先一处这样的节点中节点编号最小的那个
        // 2. 有初始感染节点的联通分量中，不存在只有一个初始感染节点的，那么无论移除哪个节点，整个联通分量都会被感染
        // 这种情况下，我们移除哪个节点都无所谓，优先移除节点编号最小的那个
        // 而对于那些没有初始感染节点的联通分量，我们根本不需要考虑
        // 现在唯一的问题就在于，我们如何找出输入图中所有的联通分量
        // 对于无向图，这通常可以通过并查集来实现
        // 先定义一个集合形式的并查集数组，每个节点初始的时候都自己代表一个集合
        vector<int> parents(n);
        vector<vector<int>> sizes(2, vector<int>(n, 0)); // 记录每个节点所在集合中感染节点的数量，初始时我们规定感染节点的数量为 0
        function<int(int)> findParent = [&](int x) 
        {
            // 找出 x 节点所在集合的代表节点
            if (parents[x] != x)
            {
                // 这里进行路径压缩，把 x 节点直接挂到代表节点下，加快后续的查找速度
                parents[x] = findParent(parents[x]);
            }
            return parents[x];
        };
        // 我们对 initial 数组进行排序，确保我们优先选择节点编号小的节点
        sort(initial.begin(), initial.end());
        // 初始化并查集，同时填充 sizes 数组
        int idx = 0;
        for(int i = 0; i < n; ++i)
        {
            if(idx < initial.size() && initial[idx] == i)
            {
                // 这是一个初始感染节点
                sizes[1][i] = 1;
                ++idx;
            }
            parents[i] = i;
            sizes[0][i] = 1; // 每个节点初始时所在集合的大小为 1
        }
        // 我们遍历图中的每一条边，把联通的节点合并到同一个集合中
        for(int i = 0; i < n; ++i)
        {
            for(int j = 0; j < n; ++j)
            {
                if(graph[i][j] == 1)
                {
                    int parentI = findParent(i);
                    int parentJ = findParent(j);
                    if(parentI != parentJ)
                    {
                        // 合并到同一个集合
                        parents[parentJ] = parentI;
                        // 更新结合的大小
                        sizes[0][parentI] += sizes[0][parentJ];
                        sizes[0][parentJ] = 0;
                        // 更新感染节点的数量
                        sizes[1][parentI] += sizes[1][parentJ];
                        sizes[1][parentJ] = 0;
                    }
                }
            }
        }

        // 拿到了联通分量，以及对应联通分量的大小后，我们可以检查每个初始感染节点所属的联通分量以及对应的分量大小
        // 1. 如果某个感染节点自己所在的联通分量中，只有它一个感染节点，那么移除它就能让整个联通分量不被感染，我们选它即可
        // masSize 用于记录当前能移除的节点中，所能拯救的最大联通分量的大小
        // 默认剔除序号最小的那个被污染节点
        int maxSize = -1, ret = initial[0];
        for(const int& node : initial)
        {
            // 检查 node 节点所在联通分量的感染节点数量
            int parentNode = findParent(node);
            // 检查 parentNode 所在的联通分量的大小
            if(sizes[0][parentNode] > maxSize && sizes[1][parentNode] == 1)
            {
                // 我们可以拯救这个联通分量，更新结果
                ret = node;
                maxSize = sizes[0][parentNode];
            }
        }
        return ret;
    }
};