#include "Solution.h"

// 记录一下二刷的错误，这道题这次应该记住了。。
// 本质是 "找下一个排列" 的翻版
// 不过需要先找 "左侧较小的数"，而不是先找 "右侧较大的数"
// 原因如下：
// 我们需要的是找出 "比当前值大的最小值"
// 所以被换到前面来的数一定要是尽量小的
// 而这里错误解法中找出的这个 "被换过来" 的数并不一定满足这个条件
// 所以我们必须先定位左侧一个尽量小的值，才能保证换过来的值也是 "尽量小的"
// 从而满足题目的 "大的最小值" 要求
// 至于寻找这个 "左侧尽量小的值" 的方法
// 我们可以想到，要换过来的值，一定要是尽量靠右的，因为这样才能保证交换后的值尽量小
// 同时，这个值还必须是不在一个从右到左连续的递增序列中的，因为这样的递增序列是字典序上说最大的序列
int Leetcode501_600::Soltuion::nextGreaterElement(int n)
{
    // 个人理解，这道题和 "下一个排列" 是几乎一样的题目，我们可以把 n 先拆成数位数组
    // 之后对这个数位数组应用和 "下一个排列" 一模一样的方案
    // 最后检查生成的新数位数组是否能用一个 32 位整数表示，如果不能，返回 -1 即可
    // 或者，如果生成的新数位数组和原来的是一样的，也返回 -1
    // 重新回顾一下 "下一个排列" 这道题目的解决方案
    // 本质上是一种贪心策略
    // 用一个具体一些的例子来帮助理解：
    // 12345 - 12354 - 12435 - 12453 - 12534 - 12543 - 13245 - 15243 - 15423 - 15432 
    // 13254 的 "下一个排列"
    // 我们本质上是要把一个尽量靠右的 "较大值" 与一个尽量靠右的 "较小值" 交换
    // 这样来理解，我们可以知道，需要往前交换的较大值应该是 4
    // 因为要是交换 5 过去的话，那么很明显不如用右边更小的这个 4 来交换更优 (也就是交换后结果更小)
    // 之后考虑把我们确定的这个 "较大值" 和左侧哪一个 "较小值" 交换
    // 不难想到应该是和 2 交换
    // 首先 5 肯定不是，因为 5 本身比 4 大，交换后不满足 "结果更大" 这个条件
    // 那么剩下的就是往左一格的这个 2 了
    // 交换后，结果变成 13452，但是这样显然还不是最贴近 13254 的
    // 我们还需要对原来 2 位置右侧的部分进行有序排列 -> 13425
    // 这个值才是最接近 13254 的
    // 总结一下找尽量靠右的 "较小值" 的方法：
    // 从之前找到的，尽量靠右的 "较大值" 的位置处，往左遍历，知道找到第一个小于这个 "较大值" 的值即可
    // 找尽量靠右的 "较大值" 的方法也不难理解：
    // 从最后一个数往前检查数值序列
    // 路径上出现的第一个上升数值对 (num[i], num[j]: num[i] > num[j])
    // 此时我们就把 num[j] 作为本次交换的 "较大值"
    // 方法基本明确，剩下的就是写代码了
    // 第一步：把 n 转储成数位数组
    vector<int> num;
    while(n)
    {
        num.push_back(n%10);
        n /= 10;
    }
    // 别忘了反转，前面 push_back() 构造出来的结果是反的
    reverse(num.begin(), num.end());
    int m = num.size();
    // 第二步：找出 "较大值"，从右往左遍历
    int i = m-1;
    for(; i >= 0; --i)
    {
        if(i == 0 || num[i] > num[i-1])
        {
            break;
        }
    }
    // 遍历结束，i 指向了找到的 "较大值" 的下标
    // 第三步：找出 "较小值"，从 i-1 处开始，右往左遍历
    // 直到找出第一个小于 num[i] 的值为止
    int j = i;
    while(j > 0 && num[j] >= num[i])
    {
        --j;
    }
    // 现在，我们交换 num[i] 和 num[j]，注意：如果 num[i] == num[j]，那么我们直接返回 -1 即可
    if(i == j)
    {
        return -1;
    }
    // 可以交换，进行交换
    swap(num[i], num[j]);
    // 最后，把 num[i] 以及后面的元素排序
    sort(num.begin()+i, num.end());
    int res = 0;
    for(int i = 0; i < m; ++i)
    {
        cout << num[i] << " ";
    }
    for(int i = 0; i < m; ++i)
    {
        // res*10+num[i] >= INT_MAX
        if(res > (INT_MAX-num[i])/10)
        {
            return -1;
        }
        res = res*10+num[i];
    }
    return res;  
}