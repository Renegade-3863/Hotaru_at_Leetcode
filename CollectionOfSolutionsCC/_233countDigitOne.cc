#include "Solution.h"

int Leetcode201_300::Solution::countDigitOne(int n)
{
    // 一道比较经典的数位 DP 类问题，我们可以考虑按给定整数的数位，逐个检查当前数位为1的合法值个数
    // 可以分以下几种情况来进行考虑
    // 下面的讨论，均假设 i 位数字左侧的值是 x，右侧的值是 y
    // 1. 当前数位是大于1的值
    // 此时当前数位完全可以为1，并且左右可以放置任何不大于原值的数字
    // 我们此时可以累计 (x+1) * (10^k) 个，其中 k 是 y 的位数，加1的原因是：左侧可以取 0-x 中的数据，右侧可以取 0-(10^k-1) 中的数据
    // 2. 当前数位是等于1的
    // 此时当前数位也完全可以为1，不过左右两侧的取值需要受到一些限制
    // 左侧仍然可以取 (x+1) 种值，不过对于左侧取 x 的情况，我们在右侧不能取到 10^k 种值了，只能取到 (y+1) 种数据，因为有不超过 n 的限制
    // 也就是说，此时我们可以累计 x * (10^k) + (y + 1) 个
    // 3. 当前数位是小于1的
    // 此时我们也自然是可以把这个数位置为1的，不过左右两侧的取值就要受到更严格一些的限制
    // 左侧不能取到 x 了，只能取到 0-(x-1) 中的值，右侧在上面这 x 种情况下都是可以取到 10^k 种值的
    // 那么此时我们可以累计 x * (10^k) 个
    // 情况讨论完了，剩下的就只有写代码了
    // 为了逻辑编写方便，我们从右向左进行遍历
    // 这个值代表分析中的 10^k，就是当前数位的幂数
    int exp = 1;
    // res 是最终结果
    int res = 0;
    // exp <= INT_MAX / 10 是用于防止整形溢出
    while(exp <= n)
    {
        // 取出左侧的值 x
        int x = n / exp;
        int cur = x % 10;
        x /= 10;
        // 取出右侧的值 y
        int y = n % exp;
        // 之后针对当前数位上的数进行上面的讨论分析
        // 情况1.
        if(cur > 1)
        {
            res += (x+1)*(exp);
        }
        else if(cur == 1)
        {
            res += (x*exp+(y+1));
        }
        else 
        {
            res += (x*exp);
        }
        // 在这里进行整形溢出检查
        if(exp >= INT_MAX/10)
        {
            break;
        }
        exp *= 10;
    }
    return res;
}