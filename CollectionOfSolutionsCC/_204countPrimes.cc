#include "Solution.h"

int Leetcode201_300::Solution::countPrimes(int n)
{
    // 本题最暴力的方案就是直接遍历所有数，检查它们是否是一个质数，不过这种方案太 nt，我们就不写了
    // 考虑质数本身的性质，我们可以发现质数之间具有某种隔离性，即，如果一个数是质数，那么所有小于它的数，无论是质数还是合数，都不可能是它的因子 (当然1要除外)
    // 这不是废话吗。。。
    // 别急，反过来，我们考虑所有合数
    // 所有合数都能拆成一组质数和一组合数的乘积！
    // 上面这句话一定是正确的对吧
    // 原因正是在于它的逆否命题：
    // 不能拆成一组质数和一组合数乘积的任何数都是质数
    // 这就是上面我们的 "废话"！
    // 所以我们知道了合数一定是由比它小的质数组合和合数组合乘出来的，那么一种解法就油然而生了：
    // 我们检出基础的一个质数2 (注意我们规定1不是质数)
    // 之后规定所有能通过它乘出来的后续值(只要它是不大于 n 的)
    // 并且规定这些值都是合数
    // 每次检完某个质数所有后续的值
    // 我们就继续遍历
    // 每次我们到达一个新值，如果前面的某个质数没有把它提前确定为 "合数"，我们就明确了它是一个 "质数"，之后按照这个策略继续进行后续值的检出，直到我们找到了最后一个值 n 为止
    // 还有一个优化方案，注意到按照上面的逻辑，我们总是会计算 2x, 3x, 4x, ... kx (kx <= n && (k+1)x > n)
    // 而实际上，我们应该能够发现，由于我们遍历的时候用的是一组连续的数字：[2, 3, 4, ... k]
    // 那么当我们检查一个值 x 的时候，实际上所有的小于它的另一个乘数都应该在前面的某个质数处被检查过了
    // 举例：x == 17
    // 对于 2x17，这个 17 一定在我们检查2这个质数的时候就计算过了，对于 3 x 17，这个17一样，对于 4 x 17，由于4本身是合数，我们可能会觉得这个17我们之前没用过
    // 不过，由于合数总是能分解质因数成一组质数的乘积，就像这里的4，可以分解成 2x2 一样，我们总能找到前面的一个质数，把所有其他组分拼到另一侧：2 x 34
    // 那么相当于 4 x 17 这个值我们前面也检查过了，没必要重新计算
    // 那么从几开始就没用过了呢？
    // 从 x 自身开始
    // 因为所有乘式，都一定是一个小值乘以一个大值，所以一定是 y x x (y 是一个小于 x 的值) 被用过，后面的所有值都没用过了
    // 根据上面的推断，想写出代码就很简单了
    vector<bool> isPrime(n, true);
    int res = 0;
    for(int i = 2; i < n; ++i)
    {
        if(isPrime[i]) 
        {
            ++res;
            for(long long j = (long long)i*i; j < n; j += i)
            {
                isPrime[j] = 0;
            }
        }
    }
    return res;
}