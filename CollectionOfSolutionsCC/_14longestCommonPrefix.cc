#include "Solution.h"

string Leetcode1_100::Solution::longestCommonPrefix(vector<string> &strs)
{
    // 本题的目标是找出一组字符串的最长公共前缀(个人认为是互联网 IP 路由转发表的地址最优匹配问题简化版)
    // 对问题进行初步的分析，分析能否使用除了线性检查之外的其它高效方法
    // 二分法似乎有搞头，不过需要进一步分析
    // 我们应该要二分的是对应下标处的字符
    // 比如现在可行的字符子串的左右边界分别是 left 和 right
    // 我们检查 s[mid]，其中 mid = (right-left)>>1+left
    // 那么我们是否可以通过一次中点检查就确定一半信息的正确性？
    // 具体点说，我们的确可以通过 strs 中所有字符串的 mid 下标处字符都相同来判断是否有可能存在这样长度的公共前缀
    // 但是我们显然没办法实际确认这种可能性
    // 因为在 mid 之前还可能存在一个截断位置，这个位置上并不是所有字符都相等
    // 故显然我们没法使用这种二分四路进行检查了，那剩下的就只能是线性增加长度，之后逐字符串比较这种方法了
    int idx = 0, n = strs.size();
    // 依然是边界情况，如果字符串数组只有一个字符串，那么我们后面的检查逻辑也没必要特殊处理，在这里退出即可
    if (n == 1)
    {
        return strs[0];
    }
    // 外层用死循环进行检查，我们在循环体内部设置一定会被触发的结束条件即可
    // 遍历所有可能的 idx 下标值
    while (1)
    {
        // 设置一个比较样本，不一定非要是第一个字符串的对应下标处的字符
        // 边界情况，如果第一个字符串长度为0，可以直接返回
        if (strs[0].size() == 0)
        {
            return "";
        }
        char c = strs[0][idx];
        // 检查每一个字符串的对应下标位置
        for (int i = 1; i < n; ++i)
        {
            if (idx >= strs[i].size() || strs[i][idx] != c)
            {
                // 如果遇到了当前字符串长度不足或者当前位有字符串不匹配，就必须返回结果了
                return strs[i].substr(0, idx);
            }
        }
        ++idx;
    }
    // 理论上说不会执行到这一行代码
    return "";
}