#include "Solution.h"

string Leetcode101_200::Solution::largestNumber(vector<int>& nums)
{
    // 本题本质上是贪心，考虑以下事实：
    // 数值上越大的元素，我们更应该把它们放到最终结果的前面，这样才能使最后的结果更大
    // 原因如下：
    // 假设有两个数 a, b
    // 如果数值上有：a > b，而此时我们把较小的 b 放到了前面，那么很显然地，会有下面的问题：
    // ba 一定在数值上会小于 ab，所以我们应该把 a 放到前面，而不是把 b 放到前面
    // 明确了上面的关系，我们需要考虑的还剩下一点：如何确定两个数的大小关系？
    // 有人认为，不就是单纯比较个大小吗？
    // 那么，考虑下面两个数：3，30
    // 30在数值上是大于3的，但是，303 和 330 哪个更大？
    // 很显然是后者，可这就意味着我们需要把数值更小的 3 放到 30 的前面
    // 那么我们显然不能遵循单纯的数值比较来判断两个数值的大小关系
    // 经过"一些"思考，我们似乎可以发现，上面的情况，可以这样判断：3(3) > 30
    // 也就是，如果两个数字的长度不相等，那么较短的那部分，我们填充结尾的这个数继续进行比较
    // 但是，这样也不是完美的(其实是第一次做的时候被这个想法给坑了)
    // 考虑下面这个例子：
    // [34323, 3432]
    // 按上面的思路：应该有：34323 > 3432(2)
    // 所以我们会得出 343233432 这个结果
    // 而实际上，反过来拼接：343234323 反而比上面的数更大，这就证伪了我们上面的思路
    // 其实比较简单的判断方法是，即然我们不容易直接判断两个数字的大小关系，从而决定谁在前谁在后，那么我们显然就可以两种拼接策略都试一次
    // 实际测试一下哪个更大就行了
    // 这样，拼接后数值更大的那个结果就是这两个数值应有的先后次序
    // 这样，我们其实相当于把原先的比较符号进行了重载，之后使用这个重载了的比较符号再对整个数组进行排序即可
    // 最后，考虑这样的事实：为什么 ab > ba，我们就可以把 a 放在最后顺序中 b 的前面？
    // 如果中间还有其它数据，会对这个关系有影响吗？
    // 具体一些：axb 和 bya 的关系是不是依然有 axb > bxa ?
    // 这个其实比较显然，就不多说明了。。。
    // 那么明确了这个比较手法，我们就可以进行最后的代码编写了
    // 先写出上面的比较函数
    function<bool(const string&, const string&)> cmp = [&](const string& a, const string& b)
    {
        return a+b > b+a;
    };
    // 把整个整数数组转存成字符串数组，之后我们就可以使用上面的排序方法代替传统的比较符号对这个数组进行排序，最后输出结果
    vector<string> numbers;
    int n = nums.size();
    for(int i = 0; i < n; ++i)
    {
        numbers.push_back(to_string(nums[i]));
    }
    sort(numbers.begin(), numbers.end(), cmp);
    string res = "";
    for(int i = 0; i < n; ++i)
    {
        res += numbers[i];
    }
    // 需要去掉前导零
    while(res[0] == '0' && res != "0")
    {
        res = res.substr(1);
    }
    return res;
}