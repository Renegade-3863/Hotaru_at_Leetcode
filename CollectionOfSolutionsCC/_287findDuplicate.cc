#include "Solution.h"

int Leetcode201_300::Solution::findDuplicate(vector<int>& nums)
{
    // 最简单的解法是直接对 nums 数组排序，再遍历一遍找出重复的数据，不过这样会消耗 O(nlogn) 的时间复杂度，即是快排可以达到 O(1) 的空间复杂度
    // 而且这没有达到题目要求的 "不修改原数组" 的要求
    // 不修改原数组？怎么做？
    // 其实这样留给我们的选择就不多了
    // 无非两个角度：
    // 1. 位运算
    // 2. 二分查找
    // 本题的数组不具备有序性质，所以二分可能也不是很合适
    // 因而剩下的只能是位运算了
    // 直入主题吧，位运算本人也想不出来只用 O(1) 空间复杂度，同时时间复杂度还是 O(n) 的算法
    // 答案给出了一个很抽象的解法：利用循环链表那一题的思路对本题进行建模
    // 如何描述呢
    // 我们把数组中任意一个分立的数值抽象成链表上的一个结点
    // 之后把数组下标和下标上的值的关系抽象成链表结点之间的指针
    // 比如 nums[0] = 4
    // 那么我们抽象出的链表中就有一个由结点 0 指向结点 4 的指针 (注意：下标范围是从 0 开始的，而原链表中只有序号 [1,n] 中的结点，因而我们这里其实相当于多初始化了一个值为0的结点)
    // 不过我们不用真的具体写出数据结构来表示这个链表，我们要做的只是模拟在这个链表上运动的整个过程
    // 考虑规定两个指针，一快一慢
    int slow = 0, fast = 0;
    // 慢指针每次移动一个结点
    do 
    {
        slow = nums[slow];
        // 快指针每次移动两个结点
        fast = nums[nums[fast]];
    }while(slow != fast);
    // 直到两个指针在某个值代表的结点上相遇
    // 此时，我们可以明确两个指针都已经停在了环内
    // 之后要做的数学推导就和循环链表那题一致了
    // 把快指针挪回头部
    fast = 0;
    // 之后二者同步移动，直到再次相遇，这个相遇点就是环的入口点，也就是重复元素的值
    while(fast != slow)
    {
        fast = nums[fast];
        slow = nums[slow];
    }
    return slow;
}