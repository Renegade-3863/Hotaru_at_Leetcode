#include "Solution.h"

void Leetcode201_300::Solution::wiggleSort(vector<int>& nums)
{
    // 本题没有一个比较好的暴力切入点，不过我们可以回归最基本的循环不变式策略
    // 考虑这样的循环不变式是否可行：
    // 每一轮循环，我们保证：下标 i 以及其左侧的元素形成一个合法的摆动排序序列
    // 具体来说：有下面的不等式成立：
    // 1. 如果 i 是偶数
    // 那么有 nums[i-1] >= nums[i] 或者 i 本身就是 0
    // 2. 如果 i 是奇数
    // 那么有 nums[i-1] <= nums[i]
    // 那么我们是否可以在每一轮循环中维护当前下标该有的性质呢？
    // 如果能的话，我们就可以简单地递推一轮到达数组结尾，从而保证整个数组的摆动排序性质了
    // 一开始，i == 0，下标 0 前面没有元素，摆动排序性质是自然保证的
    // 之后，我们从左往右进行循环
    // 对于情况1
    // 我们知道它左边的摆动性质已经被满足了，所以现在要做的是满足 nums[i] <= nums[i+1]
    // 不难看出有两种可能性
    // 1) 本身 nums[i] <= nums[i+1] 就是成立的
    // 此时我们很明显不用进行修改，因为下标 i 的摆动性质已经得到了满足
    // 2) 本身 nums[i] > nums[i+1]
    // 那么此时最简单的修改办法是把 nums[i] 和 nums[i+1] 进行交换
    // 这样交换后 i 位置的元素对右侧元素就满足了摆动性质
    // 提问：这样是否会破坏 i 位置和它左边位置 (i-1) 的摆动性质？
    // 结论是不会
    // 因为 nums[i+1] < nums[i] (交换前)
    // 同时 nums[i] <= nums[i-1] (交换前)
    // 那么很显然，交换后
    // nums[i](原来的 nums[i+1]) < nums[i-1] (没看懂的可以自己推一推不等关系，不难)
    // 这说明我们的交换不会破坏位置 i 已有的左侧摆动性质
    // 至于前面数字的摆动性质，因为我们的摆动性质只作用于三个数之间，因而交换这两个位置的元素不可能影响再前面的元素
    // 对于情况2
    // 同样不难看出有两种可能性
    // 1) 本身 nums[i] >= nums[i+1] 就是成立的
    // 此时我们很明显不用进行修改，因为下标 i 的摆动性质已经得到了满足
    // 2) 本身 nums[i] < nums[i+1]
    // 那么此时最简单的修改办法还是把 nums[i] 和 nums[i+1] 进行交换
    // 不难推断出这样同样不会影响 i 位置对它左侧元素的摆动性质
    // 至此，方法就找出来了
    // 写代码就很简单了
    // 最后一个数字不用维护右侧摆动性质，它是自动满足的
    int n = nums.size();
    for(int i = 0; i < n-1; ++i)
    {
        // 情况1
        if(i % 2 == 0)
        {
            if(nums[i+1] < nums[i])
            {
                swap(nums[i+1], nums[i]);
            }
        }
        // 情况2
        else
        {
            if(nums[i+1] > nums[i])
            {
                swap(nums[i+1], nums[i]);
            }
        }
    }
    return;
}