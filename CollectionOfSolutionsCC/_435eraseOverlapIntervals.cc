#include "Solution.h"

int Leetcode401_500::Solution::eraseOverlapIntervals(vector<vector<int>>& intervals)
{
    // 经典的贪心类问题，而区间类的这种贪心问题，基本就是：按区间起点排序/按区间终点排序
    // 本题思考应该怎么排序
    // 应该想到需要按终点排序
    // 我们这样排序之后，有一个好处
    // 后面遍历到的区间一定比前面所有区间(无论是否删掉了)的结束时间都要晚
    // 我们考虑如何对待每一个遍历到的新区间
    // 首先，我们假设这个新遍历到的区间前面的所有区间都没有重叠，并且是以最优的方式完成了去重
    // 那么对于当前这个区间，我们需要判断前面是否存在一个和它有重叠的区间
    // 如果有，那么显然我们必须要么得删掉前面的这个重叠区间，要么得删掉当前这个区间
    // 不然就会有重叠(我们暂且叫它"不可避免的删除")
    // 那么删谁可以达到更好的效果呢？就是：不会因为这个操作后面可能删除更多的区间？
    // 不难想到是要删除当前这个区间
    // 解释原因的话，直接思考可能有些困难，我们以条件分析的形式来考虑
    // 假设前一个区间为 i1，后一个为 i2
    // 无非三种情况
    // 1. 我们后面不会再有任何区间和 i1 或者 i2 重合
    // 那么此时其实删除谁都无所谓
    // 2. 我们后面会有区间和 i1 再次重叠
    // 这里不难发现，因为 i1 和 i2 本身就是重叠的，那么我们同样可以得出："后面的区间和 i2 也重叠"
    // 那么此时我们无论保留谁，后面也会遭遇冲突，所以也是删除谁都一样的
    // 3. 后面会有区间和 i2 再次重叠
    // 此时注意到：因为 i1 和 i2 的重叠部分可能比较靠前，因而我们有可能会得到：i1 和这个后面的区间不重叠 的结论
    // 所以此时，我们如果删除 i2，后面的这个区间就不会因为我们保留了 i2 而遇到重叠问题，所以就可以保留了
    // 经过上面的简单分析，我们得出结论：既然无论如何都要丢掉一个，那么我们最好是丢掉 i2 这个新区间，保留 i1 这个旧区间
    // 最后，我们在检查的过程中，应该发现：我们只需要检查当前这个新区间和保留的那些不重叠区间中最后一个是否有重叠即可
    // 因为保留的区间满足了结束点非降序的原则，所以只要结束时间最晚的这一个区间有重叠，就可以决定丢弃现在这个新区间了
    // 明确了基本思路，剩下的就是写代码了
    // 进一步优化，因为题目要求我们求解的是最后要删掉的区间数量，所以我们并不用保存每一个区间，只需要保存现在保留了的区间中最后一个的结束时间这个变量即可
    // 最开始没有任何区间被选中，初始化值为 0
    // 最后考虑一点：如果有两个区间的结束时间一样，怎么做？
    // 我们不难发现此时应该保留的是总区间长度更短的哪一个区间，也就是开始时间更晚的那一个区间
    // 所以我们在排序的时候，对于结束时间相同的区间，按照开始时间降序排列即可适配上面的逻辑
    int last = INT_MIN;
    int res = 0;
    // 按结束时间对区间进行排序
    sort(intervals.begin(), intervals.end(), [&](const vector<int>& a, const vector<int>& b) {
        return a[1] == b[1] ? a[0] > b[0] : a[1] < b[1];
    });
    // 之后就是正常的遍历流程了
    for(const vector<int>& interval : intervals)
    {
        // 根据当前区间是否覆盖了 last 进行判断
        // 没有覆盖，那么我们可以保留这个新区间，并更新 last
        if(interval[0] >= last)
        {
            last = interval[1];
        }
        else
        {
            // 否则，有重复，我们删掉当前区间
            // 并记录一次删除
            ++res;
        }
    }
    return res;
}