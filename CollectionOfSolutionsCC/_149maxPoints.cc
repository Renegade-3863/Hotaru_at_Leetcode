#include "Solution.h"

int Leetcode101_200::Solution::maxPoints(vector<vector<int>>& points)
{
    // 本题个人认为没有任何算法可言，本质就是一道数学模拟题，而且有一些计算机底层存储逻辑上的细节问题需要注意
    // 考虑最朴素的解法，我们枚举每个点作为直线的一个端点
    // 记录从这个端点出发的所有出现过的斜率
    // 基于高中/初中知识，我们应该知道一个点和一个斜率是可以唯一确定一跳直线的
    // 所以，如果我们在枚举所有可能的第二个端点的过程中，计算出了之前记录过的斜率，那么我们显然就可以更新对应斜率的直线个数，同时也可以更新全局的最大共线点个数
    // 首先针对起始点进行枚举
    // 这里重申一下基本的算法逻辑：就是求出：和每个点共线的最多点数，而和每个点共线的最多点数值的最大值，也就是我们最后的答案
    if(points.size() == 0)
    {
        return 0;
    }
    // res 是全局的最大值，初始为1，因为 points 点集中至少有1个结点，因而最少是只有一个点自己共线
    int n = points.size(), res = 1;
    for(int i = 0; i < n; ++i)
    {
        // 针对每个枚举的结点，记录一个斜率表
        // 存储的键值对是：
        // (k, cnt)
        // 即：从这个点出发，斜率为 k 的重合直线上出现的点的数量
        unordered_map<double, int> cnts;
        // 考虑这样一个问题：我们应该从哪里开始枚举第二个端点？
        // 不难发现我们其实应该从 i+1 开始枚举，而不是从 0 开始
        // 有两个原因：
        // 1. 如果 i == j，那么我们显然没法计算一条只能确定一个端点的直线的斜率
        // 2. 如果 j < i，即我们举出的第二个端点出现次序在 i 前面，那么我们肯定在前面 i 更小(具体地，i == j的时候) 就检查过这条直线了，现在又检查一次，显然不合理
        // 再细一点讲，是这样的原因：
        // 如果这个 i 端点前面的某个点 j 和它以某种斜率共线了，那么包括 i 端点在内点所有后序可以与 i 以某种斜率共线的结点 j 都应该已经被检查过了，这里我们无需再重复做检查
        for(int j = i+1; j < n; ++j)
        {
            // 不过还有一个问题：如果出现正无穷这个斜率怎么办？
            // 计算机对于除以 0 的处理会导致一些不一致问题的出现
            double slope = 0.0;
            if(points[i][0] != points[j][0])
            {
                slope = (double)(points[i][1]-points[j][1])/(points[i][0]-points[j][0]);
            }
            else
            {
                // C++ 对于正无穷的处理，也就是除以0的处理，是根据被除数的正负情况来定义的
                // 如果被除数是负数，那么结果会是负无穷，相反则是正无穷
                // 而根据我们这道题而言，两种斜率其实是等价的，都是一条垂直于 x 轴的直线，所以这里需要特殊处理，使它们都等于正无穷(即DBL_MAX)
                slope = DBL_MAX;
            }
            // 注意，因为是第一次记录这种斜率，我们需要给定的初始值应该是2，而不是1
            if(cnts.find(slope) == cnts.end())
            {
                cnts[slope] = 2;
            }
            else
            {
                ++cnts[slope];
            }
            // 更新全局的最大值
            res = max(res, cnts[slope]);
        }
    }
    // 遍历结束后，直接返回结果即可
    return res;
}