#include "Solution.h"

int Leetcode101_200::Solution::canCompleteCircuit(vector<int>& gas, vector<int>& cost)
{
    // 我们可以采用类似贪心的方案
    // 考虑：
    // 如果我们从某个下标出发进行模拟，能达到的最远位置不是它本身(假设一共有 n 个加油站，这个意思就是说我们没法从这个下标出发走 n 步就会耗尽所有油量)
    // 那么不难发现，如果我们从我们从刚刚这个出发点模拟出来的所有下标上出发，都没法走得更远，因为不可能有任何一个加油站的油量
    // 那么假设我们从刚刚模拟出来的路径上起点之后的下标出发进行模拟，我们都不可能走回到这个后面的起点(因为我们甚至走不回前面的这个起点)
    // 因而只要我们模拟出从某个下标位置出发，走不回它本身，那么直到它最远能到的下标之间的所有下标都不用检查了，它们都不可能是合法的解
    // 这样我们就找到了一个很巧妙的 O(n) 的解法
    // 写出代码就很简单了
    // n 为加油站的总个数，steps 为从当前选定的起点最远可以走的步数，这个步数如果达到了 n，那么就说明我们从当前选定的这个起点可以绕环路一圈，否则就不行
    int steps = 0, n = gas.size();
    // gasStore 代表当前情况下汽车油箱中的油量，用于判断下一步可不可以走
    int start = 0, gasStore = 0;
    // 循环遍历整个环路上的所有下标作为起点
    while(start < n)
    {
        int cur = start;
        // 每次从新的 start 开始检查的时候，我们需要重置走过的步数为 0
        gasStore = 0;
        steps = 0;
        // 循环不断检查下一步可不可以走，动态更新步数
        // 退出条件为：要么我们还没走回 start 下标，油量就不够用了
        // 要么我们成功走回了 start (即 cur 再一次等于了 start)，此时也可以退出检查了
        do
        {
            // 先加油，再尝试前进
            gasStore += gas[cur];
            // 如果加完油无法继续前进，就退出这个起点的检查
            if(gasStore < cost[cur])
            {
                break;
            }
            // 否则，可以继续前进，就前进一步
            // 耗油
            gasStore -= cost[cur];
            // 前进一步
            // 注意，如果走到了数组结尾，我们需要使用取模运算返回数组开始，模拟一个环形数组
            cur = (cur+1) % n;
            ++steps;
        } while(cur != start);
        // 如果找到了可行的起点，我们就可以直接返回 这个起始下标
        if(steps == n)
        {
            return start;
        }
        // 否则，根据我们上面的逻辑，可以丢弃刚刚在内层循环中检查到的所有下标，这些都不可能是起点
        start += steps+1; 
    }
    return -1;
}