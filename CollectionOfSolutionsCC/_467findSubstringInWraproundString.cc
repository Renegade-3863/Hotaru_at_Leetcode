#include "Solution.h"

int Leetcode401_500::Soltuion::findSubstringInWraproundString(string s)
{
    // 我们尝试从本质上入手这道题
    // 题目的要求无非是：找出 s 中所有的按字典序连续的子串 (包括长度为1的子串)
    // 那么我们的解决办法也不难想到
    // 采用类似 dp 的方法来解决这道题：
    // 先从 DFS 来进行切入：
    // 定义一个子问题：
    // dfs(i) 代表以 s[i] 结尾的合规非空子字符串的长度
    // 一开始，我们先不考虑去重问题，只考虑最简单的递推定义
    // 那么不难想出递推的方式：
    // dfs(i) 无非两种可能：
    // 1. s[i] 和 s[i-1] 可以接上
    // dfs(i) = dfs(i-1)+1
    // 2. s[i] 和 s[i-1] 是断开的
    // dfs(i) = 1
    // 最后所有 dfs(i) 的结果累加起来，就是我们要的结果 (这个思想类似序列 DP)
    // 搞定了递推关系，剩下的就是思考如何去重了
    // 本题的子串都有一个特性：
    // 固定了结尾字符，以及子串长度，实际上的子字符串就是确定的
    // 所以我们去重可以从这一点来入手 (实际上，个人认为这个思考角度其实挺难想到的。。)
    // 我们可以保存一个数组，这个数组记录以每种字符 (一共26种英文字母) 结尾的已经记录的子字符串中最长的那一个的长度
    // 如果某个 dfs(i) 的结果大于等于了此刻记录过的，以 s[i] 这个字符结尾的最长非空连续子串，那么就更新对应的记录
    // 否则，不进行更新
    // 全部遍历完成后，累加以每种字符结尾的最长连续子串长度，就是结果了
    vector<int> memo(26, 0);
    int n = s.size();
    // 每个下标的结果至少是 1，所以我们这里把值初始化为 1 即可
    vector<int> dp(n, 1);
    // 进行实际的遍历
    for(int i = 0; i < n; ++i)
    {
        // 执行递推逻辑
        // 可以累加，那就累加
        if(i > 0 && ((s[i]+26)-s[i-1])%26 == 1)
        {
            dp[i] += dp[i-1];
        }
        // 否则，维持 dp[i] == 1
        // 对 memo 中记录的结果进行更新
        memo[s[i]-'a'] = max(memo[s[i]-'a'], dp[i]);
    }
    // 求和返回即可
    return accumulate(memo.begin(), memo.end(), 0);
}

// 一维空间优化为单个变量
int findSubstringInWraproundString(string s)
{
    // 我们尝试从本质上入手这道题
    // 题目的要求无非是：找出 s 中所有的按字典序连续的子串 (包括长度为1的子串)
    // 那么我们的解决办法也不难想到
    // 采用类似 dp 的方法来解决这道题：
    // 先从 DFS 来进行切入：
    // 定义一个子问题：
    // dfs(i) 代表以 s[i] 结尾的合规非空子字符串的长度
    // 一开始，我们先不考虑去重问题，只考虑最简单的递推定义
    // 那么不难想出递推的方式：
    // dfs(i) 无非两种可能：
    // 1. s[i] 和 s[i-1] 可以接上
    // dfs(i) = dfs(i-1)+1
    // 2. s[i] 和 s[i-1] 是断开的
    // dfs(i) = 1
    // 最后所有 dfs(i) 的结果累加起来，就是我们要的结果 (这个思想类似序列 DP)
    // 搞定了递推关系，剩下的就是思考如何去重了
    // 本题的子串都有一个特性：
    // 固定了结尾字符，以及子串长度，实际上的子字符串就是确定的
    // 所以我们去重可以从这一点来入手 (实际上，个人认为这个思考角度其实挺难想到的。。)
    // 我们可以保存一个数组，这个数组记录以每种字符 (一共26种英文字母) 结尾的已经记录的子字符串中最长的那一个的长度
    // 如果某个 dfs(i) 的结果大于等于了此刻记录过的，以 s[i] 这个字符结尾的最长非空连续子串，那么就更新对应的记录
    // 否则，不进行更新
    // 全部遍历完成后，累加以每种字符结尾的最长连续子串长度，就是结果了
    vector<int> memo(26, 0);
    int n = s.size();
    // 每个下标的结果至少是 1，所以我们这里把值初始化为 1 即可
    // vector<int> dp(n, 1);
    // 更换定义：换一维数组为单个变量
    int dp = 1;
    // 进行实际的遍历
    for(int i = 0; i < n; ++i)
    {
        // 执行递推逻辑
        // 可以累加，那就累加
        if(i > 0 && ((s[i]+26)-s[i-1])%26 == 1)
        {
            ++dp;
        }
        // 否则，维持 dp[i] == 1
        else
        {
            dp = 1;
        }
        // 对 memo 中记录的结果进行更新
        memo[s[i]-'a'] = max(memo[s[i]-'a'], dp);
    }
    // 求和返回即可
    return accumulate(memo.begin(), memo.end(), 0);
}