#include "Soluton.h"

bool Leetcode1_100::Solution::isMatch44(string s, string p)
{
    // 本题是第10题的条件变更版，本题的星号可以匹配任意的字符序列，而不是像第10题那样只能匹配单一字符构成的序列
    // 本题依然可以使用动态规划的思路进行检查
    // 假设 dp[i][j] 代表 s 的前 i 个字符和 p 的前 j 个字符能否成功匹配
    // 那么 dp[0][0] 显然是 true (两个空字符串显然是能够互相匹配的)
    //     dp[i][0] 显然都是 false，因为模式串是空的，除了空字符串以外，它匹配不了任何字符串
    //     dp[0][j] 需要视情况而定，按理来说，只要这个 p 的子串以 '*' 结尾，同时前面也是可以匹配的：dp[0][j-1]，这样就说明 dp[0][j] 可以匹配
    // 那么，由于问号和星号都只在 p 中出现
    // 我们可以进行如下的分类讨论
    // 1. p[j-1] 是普通字符
    /*
        这种情况比较单纯，只需要检查 s[i-1] 是否等于 p[j-1] 即可
        如果等于，那么当前两位可匹配，如果前面的前缀也可以匹配，那么当前两个字符串就可以匹配
        即：
        if(p[j-1] is a normal character)
        {
            dp[i][j] = s[i-1] == p[j-1] && dp[i-1][j-1]
        }
    */
    // 2. p[j-1] 是问号
    /*
        其实可以合并到第一种情况
        if(p[j-1] == '?')
        dp[i][j] = dp[i-1][j-1]
    */
    // 3. p[j-1] 是星号
    /*
        这种情况稍微比较复杂，不过由于这里星号的能力比第十题中更加强大，所以检查难度比第十题简单很多
        正常来看，我们只需要判断需要用这个星号匹配多长的序列
        也就是
        dp[i][j] = dp[i][j-1] || dp[i-1][j] || dp[i-2][j] || ... || dp[0][j]
        和第十题一样，我们考察
        dp[i-1][j] = dp[i-1][j-1] || dp[i-2][j] || dp[i-3][j] || ... || dp[0][j]
        同样的重复，同样的可省
        于是有：
        dp[i][j] = dp[i][j-1] || dp[i-1][j]
        这里和第十题唯一的区别就是，星号本身不匹配的时候，递推是从 dp[i][j-1] 过来，而不是 dp[i][j-2] 过来
    */
    // 思路清晰了之后，我们就可以写代码了
    int m = s.size(), n = p.size();
    vector<vector<bool>> dp(m+1, vector<bool>(n+1, false));
    // 边界情况设定
    dp[0][0] = true;
    for(int j = 1; j <= n; ++j)
    {
        dp[0][j] = p[j-1] == '*' ? dp[0][j-1] : false;
    }
    // 执行递推过程
    for(int i = 1; i <= m; ++i)
    {
        for(int j = 1; j <= n; ++j)
        {
            if(p[j-1] == '*')
            {
                dp[i][j] = dp[i][j-1] || dp[i-1][j];
            }
            else
            {
                // 只有这两种情况下才可以递推
                if(p[j-1] == '?' || s[i-1] == p[j-1])
                {
                    dp[i][j] = dp[i-1][j-1];
                }
            }
        }
    }
    return dp[m][n];
}