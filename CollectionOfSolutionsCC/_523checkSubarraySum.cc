#include "Solution.h"

bool Leetcode501_600::Soltuion::checkSubarraySum(vector<int>& nums, int k)
{
    // 注意，本题要求的子数组必须是连续的子部分，要和子序列区分开
    // 一般涉及到这种 "子数组和" 的题目，不是前缀和就是动态规划，而本题并没有涉及到任何的 "最优值问题"
    // 所以我们考虑用前缀和相关的方法来求解
    // 可以用这样的方法来切入
    // 假设我们记录了一组前缀和：
    // 从下标 0 到当前下标 i
    // 那么我们需要做的是，检查前缀和值集合中是否存在：0*k, 1*k, 2*k, ..., 直到 m*k 的值大于 preSum[i] (preSum[i] 为下标 i 的前缀和) 为止
    // 注意到，本题限定了 nums[i] 均为非负数，这是我们上面的检查序列有限的必要条件，如果包含负数，那么我们就还需要检查负数，这样遍历的子部分就更长了
    // 而检查某个前缀的方法不难想到，一个哈希表就解决了
    // 定义一个哈希集合，记录某个值是否存在过
    // 同时，注意到我们只需要检查 "是否存在"，所以我们并不实际需要记录一个前缀数组，记录一个前缀值即可
    int preSum = 0, n = nums.size();
    // 记录已经出现过的前缀值
    // 注意，题目要求的 "好子数组" 的长度至少为 2，所以我们需要一种方案来判断是否能够切出来一个长度至少为 2 的子数组
    // 所以我们把哈希集合改成哈希表，键记录对应的值，值记录 "这个值对应的前缀和最早出现的下标"，因为最早出现的下标是可以组成最长的前缀的
    unordered_map<int, int> memo;
    // 记录前缀和 0 最早出现的下标为 -1，也就是 "不含任何数值的前缀"
    memo[0] = -1;
    for(int i = 0; i < n; ++i)
    {
        // 累加前缀和
        preSum += nums[i];
        // 遍历 0*k 到 m*k，看是否存在对应和到子数组，存在就直接返回 true，否则继续检查
        int sum = 0;
        while(sum <= preSum)
        {
            if(memo.count(preSum-sum) && i-memo[preSum-sum] >= 2)
            {
                // 找到了对应的子数组，并且长度可行，返回 true 即可
                return true;
            }
            // 否则，没找到，给 sum 加一个 k，继续检查
            sum += k;
        }
        // 记录前缀和
        if(!memo.count(preSum))
        {
            memo[preSum] = i;
        }
    }
    // 没找到结果，返回 false 即可
    return false;
}

// 上面第一种遍历 k 的参数 m 的策略属于平方级别，时间复杂度过高，倒在了 [1, 10000001000000000]，k = 1 这个用例上
// 所以我们需要一种优化的方案，不难察觉，唯一的优化点就是这个遍历 k 的倍数的步骤
// 说实话，这道题如果没做过，或者对数论不熟悉的话，是真的很难想到最后的优化逻辑
// 我们总结一下之前用来判断的逻辑：
// 无非就是：preSum[i]-preSum[j] == m*k (m 为任意满足 m*k <= preSum[i] 的非负整数值)
// 那么我们可以进行一下转换：
// preSum[i]/k-preSum[j]/k == m，m 很明显是一个非负整数
// 用正常数学的角度来理解这个算式，我们会发现，preSum[i] 和 preSum[j-1] 必须满足：对 k 的除法，余数相等
// 这样考虑：正常除法，小数作为商，和把商的小数部分和整数部分拆开成两部分其实是一样的，也就是说，小数部分相等 = 余数相等
// 从这个角度，我们不难发现：只要 preSum[i] 和 preSum[j-1] 对 k 做除法的余数相等，那么我们就可以说找到了一个可行的数组
// 那么我们实际上只需要对上面的代码做一点修改：
// 哈希表内部存储的数据，从原来的前缀和，变成 "前缀和对 k 的余数"
// 我们省去对 k 倍数的遍历步骤，只要找到了对应相等的余数，我们就返回 true
bool checkSubarraySum(vector<int>& nums, int k)
{
    // 注意，本题要求的子数组必须是连续的子部分，要和子序列区分开
    // 一般涉及到这种 "子数组和" 的题目，不是前缀和就是动态规划，而本题并没有涉及到任何的 "最优值问题"
    // 所以我们考虑用前缀和相关的方法来求解
    // 可以用这样的方法来切入
    // 假设我们记录了一组前缀和：
    // 从下标 0 到当前下标 i
    // 那么我们需要做的是，检查前缀和值集合中是否存在：0*k, 1*k, 2*k, ..., 直到 m*k 的值大于 preSum[i] (preSum[i] 为下标 i 的前缀和) 为止
    // 注意到，本题限定了 nums[i] 均为非负数，这是我们上面的检查序列有限的必要条件，如果包含负数，那么我们就还需要检查负数，这样遍历的子部分就更长了
    // 而检查某个前缀的方法不难想到，一个哈希表就解决了
    // 定义一个哈希集合，记录某个值是否存在过
    // 同时，注意到我们只需要检查 "是否存在"，所以我们并不实际需要记录一个前缀数组，记录一个前缀值即可
    int preSum = 0, n = nums.size();
    // 记录已经出现过的前缀值
    // 注意，题目要求的 "好子数组" 的长度至少为 2，所以我们需要一种方案来判断是否能够切出来一个长度至少为 2 的子数组
    // 所以我们把哈希集合改成哈希表，键记录对应的值，值记录 "这个值对应的前缀和最早出现的下标"，因为最早出现的下标是可以组成最长的前缀的
    unordered_map<int, int> memo;
    // 记录前缀和 0 最早出现的下标为 -1，也就是 "不含任何数值的前缀"
    memo[0] = -1;
    for(int i = 0; i < n; ++i)
    {
        // 累加前缀和
        preSum += nums[i];
        // 遍历 0*k 到 m*k，看是否存在对应和到子数组，存在就直接返回 true，否则继续检查
        // 这里做一些修改，我们只需要检查是否有合法的，对 k 取模结果为 preSum%k 的前缀和即可
        if(memo.count(preSum%k) && i-memo[preSum%k] >= 2)
        {
            // 找到了对应的子数组，并且长度可行，返回 true 即可
            return true;
        }
        // 记录前缀和
        if(!memo.count(preSum%k))
        {
            memo[preSum%k] = i;
        }
    }
    // 没找到结果，返回 false 即可
    return false;
}