#include "Solution.h"

bool Leetcode1_100::Solution::isMatch(string s, string p)
{
    // 可以说是新手噩梦时期的一道动态规划题，其实本身的逻辑不难想，比较抽象的
    // 是递推过程的优化哪一步，我们慢慢思考，写一写公式就不难看出优化策略了
    // 首先是递推的状态定义，基于动态规划"要求什么设什么定义式"的原则(虽然是个梗，但是经常有奇效)
    // 我们设 dp[i][j] 代表 s 的前 i 个字符组成的字符串和 p 的前 j 个字符组成的字符串能否实现正则匹配
    // 那么实际上不难想到一种递推关系
    // 如果 s[i-1] == p[j-1] || p[j-1] == '.'，就是本身 s[i-1] 和 p[j-1] 就能匹配，不需要'*'星号的参与
    // 那么我们可以有一种直接的递推关系：dp[i][j] = dp[i-1][j-1] (就是如果前面的部分能匹配，那么我就能匹配)
    // 其它情况：s[i-1] != p[j-1] && p[j-1] != '.'，就是没法通过正常的情况进行匹配
    // 那么我们很显然没法在 p[j-1] 同时不等于'*'进行匹配(只有这一位是星号的时候，我们才有可能向前借字符来匹配这个 s[i-1])
    // 拆分其它情况出一个子情况：p[j-1] == '*'
    // 此时，我们显然有很多种递推出 dp[i][j] 的办法，这取决于我们要用p[j-2](就是星号前面的这个字符)尝试匹配多少个字符
    // 尝试匹配零个：dp[i][j] = dp[i][j-2]
    // 尝试匹配一个：dp[i][j] = dp[i-1][j]
    // 尝试匹配两个：dp[i][j] = dp[i-2][j]
    //  ...
    // 尝试匹配整个s[0..i]：dp[i][j] = dp[0][j]
    // 不难看出上面这一堆的或值就是此时 dp[i][j] 的结果 
    // 即：if(p[j-1] == '*') dp[i][j] = dp[i][j-2] | dp[i-1][j] | dp[i-2][j] | ... | dp[0][j]
    // 大家可能会觉得，这里又需要一个循环了，实际上，我们先看一下这个式子，做一下高中时候类似数列求通项的重写
    // 把 i 变成 i-1：dp[i-1][j] = dp[i-1][j-2] | dp[i-2][j] | dp[i-3][j] | ... | dp[0][j]
    // 其实你会发现，抛开dp[i][j-2] 和 dp[i-1][j-2] 这两项的不同，其实 dp[i-1][j] 自己就能代替它后面这一串值了！
    // 这是一个很重要的发现，因为它，我们可以省去很多重复的循环迭代
    // 讲清楚了逻辑，代码写起来就行云流水了

    // 长度信息
    int m = s.size(), n = p.size();
    // 最终答案就是dp[m][n]
    vector<vector<bool>> dp(m+1, vector<bool>(n+1, false));
    // DP传统艺能，设置边界情况
    // dp[0][0] 显然是 true，两个长度都是0的子串显然可以互相匹配
    // dp[0][j] 这一组信息的设置也有点绕，一点点来分析
    // 如果 p 串有一组由于星号而可以完全省略不匹配的有长度前缀，那么显然对于这部分，dp[0][j] 都应该是 true
    // 如何判断？同样可以用递推的思想
    // if(p[j-1] == '*') dp[0][j] = dp[0][j-2]
    // else dp[0][j] = false
    dp[0][0] = true;
    for(int j = 1; j <= n; ++j)
    {
        // 只有看到了一个星号，才能丢弃一个字符和前面的前缀再尝试匹配，否则就无法匹配
        if(p[j-1] == '*')
        {
            dp[0][j] = dp[0][j-2];
        }
    }
    // 不难发现所有的 dp[i][0] 都一定是 false
    for(int i = 1; i <= m; ++i)
    {
        for(int j = 1; j <= n; ++j)
        {
            // 正常情况，需要严格判断对应的两个字符能否互相匹配
            if(p[j-1] != '*')
            {
                dp[i][j] = (s[i-1] == p[j-1] || p[j-1] == '.') && dp[i-1][j-1];
            }
            // 有通配符，需要按照我们上面总结的思路进行递推
            else
            {
                // 首先，把不用这个通配符的结果考虑进来
                dp[i][j] = dp[i][j-2];
                // 其次，考虑能否用前一个字符进行匹配，能的话，再把 dp[i-1][j] 考虑进来
                if(s[i-1] == p[j-2] || p[j-2] == '.')
                {
                    dp[i][j] = dp[i][j] | dp[i-1][j];
                }
            }
        }
    }
    // 返回结果即可
    return dp[m][n];
}