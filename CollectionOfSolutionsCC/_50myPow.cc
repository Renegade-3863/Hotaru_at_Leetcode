#include "Solution.h"

double Leetcode1_100::Solution::myPow(double x, int n)
{
    // 要求自己实现一个求幂次方的运算函数
    // 简单的累乘肯定是复杂度过高的，不是我们首选的方案，故考虑一些更快的方案
    // 学过操作系统的人应该都了解过一种叫做 "快速幂" 的算法
    // 这是一种很常用的运算优化策略，也用在很多其它运算当中，比如快速乘、快速除等
    // 基本思想其实就一句话
    // 被运算数本身可以保持不变，运算数是可以转化为二进制进行表示的
    // 举例：3^10 = 3^(1010)2
    // 也就等于 3^(2^3+2^1)
    // 进一步等于 3^(2^3)*3^(2^1)
    // 我们会发现，无论幂多大，我们总能把这个幂拆成类似这样的2的幂的组合
    // 我们不再需要计算任何其它 3 的幂指数结果
    // 原理思考清楚之后，剩下的就是实现技巧了
    // 写一下代码比讲一堆道理简单
    // base 用于记录 x 的每个2的指数次幂次方的结果
    double base = x;
    // 对 n 应用移位运算求出我们上面转化的二进制表达式
    // res 记录最终结果
    double res = 1;
    // 注意我们的移位策略可能不适用于负数次幂，我们可以把负数次幂转化成正数，求了对应次方后再求倒数(这里有个小瑕疵：如果求正数次方溢出了怎么办？)
    // 实测有这样的用例会炸
    // x = 1.00000, n = -2147483648
    // 个人没有太好的解决办法，只能把 n 转存进一个 long long 类型中了(有更好办法的请不吝赐教，要是特判就算了...)
    int sign = 1;
    long long power = n;
    if(power < 0)
    {
        sign = ~sign+1;
        power = ~power+1;
    }
    // 按 power 为正数进行求解
    // 当 power 变成 0 的时候退出循环即可
    while(power)
    {
        // 每次对 power 取最低二进制位，并检查是否需要乘上对应的 x 的2的指数次幂次方的结果
        if(power % 2)
        {
            res *= base;
        }
        // 计算 base^2
        // 实际上，相当于 x -> x^2
        //              x^2 -> x^4 (x^(2^2))
        //              x^4 -> x^8 (x^(2^3))
        //              ...
        base *= base;
        // 把 power 的最低二进制位清除(已经计算过了)
        power >>= 1;
    }
    // 循环结束后，就剩下检查正负这一条了
    // 最后，如果指数原来是负数，就求倒数即可
    return sign < 0 ? 1/res : res;
}