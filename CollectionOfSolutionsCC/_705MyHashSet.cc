#include "Solution.h"

// 一道数据结构的基础题，我们来思考一下如何设计一个哈希结构
// 设计一个哈希集合需要考虑的问题主要有三个：
// 1. 使用什么样的格式来存储数据
// 2. 如何更好地进行映射，减少哈希冲突
// 3. 如何处理哈希冲突
// 总结一下上面三个问题的答案，只是众多实现方式中常用且简单的一种：链式方法
// 1. 我们使用多链表组合的方式来进行数据存储：具体地，使用一个数组，存储一组链表的头结点，哈希到数组对应下标的时候我们把值存到对应的链表中
// 在定位的时候我们在对应的下标存储的链表中进行检索
// 2. 我们这里采用最简单的映射方案，除法哈希来实现，乘法哈希和双重哈希的实现涉及到比较严谨的数学证明，实现比较复杂。。
// 具体地：hash(key) = key % p (p 为较大的素数，例如 13131)
// 3. 链式实现处理哈希冲突比较消极，体现为 "不处理"，即直接把冲突的结点值存储到一个链表中，当出现哈希冲突的时候，就在对应的冲突链表中线形检索对应的 key 值来决定是否真的存在
// 思考一下实现上面的结构都需要哪些基本构件
// 首先，需要一个数组存储头结点，这个不用额外准备自定义结构
// 其次，由于我们不常用 list 结构 (不过 list 结构是 C++ STL 自带的链表结构，能用上当然更好)
// 那么我们可以尝试自己实现一个双链表结构 (双链表在结点的添加和删除中是更方便的)
// 不过这里 707 题就是用来练习手写双链表结构的，所以本题就使用 list 代替手写双链表了，简化一下实现难度hhh

Leetcode701_800::Soltuion::MyHashSet::MyHashSet()
{
    // 构造函数我们实际上不用做任何事，如果觉得有必要，可以再引入一个哈希集合中的元素个数变量，不过这里没要求，所以就不加了
    // 不过数组还是需要初始化的，我们定义了一个较大的素数，那么实际上链表集合的大小应该和这个值是一致的
    // 使用作用域运算符调用类内的静态成员变量
    // 这里引入一下 C++ 静态变量的初始化问题
    // 对于一个静态变量，无论它是成员变量还是全局变量，只要它不是运行时的局部变量 (即没有被函数的大括号作用域包裹)
    // 它都是在编译器就被初始化好了的
    // 所以这里在类对象的构造函数中，我们是可以调用类本身的静态成员变量的
    // 这个很重要，要记住！
    this->lists = vector<list<int>>(MyHashSet::p);
}

void Leetcode701_800::Soltuion::MyHashSet::add(int key)
{
    // 添加值的操作很简单，不过由于我们需要实现的是一个 set，而不是 multiset，也就是说，哈希集合中的元素是不允许重复的
    // 所以我们在计算好的对应的桶之后，还需要遍历对应桶，确认这个桶中不存在这个 key 值，只有不重复，我们才能添加
    int h = MyHashSet::hash(key);
    // 一个小细节，因为 list::begin() 函数返回的是一个迭代器的右值，所以我们不能用 auto& 来左值引用这个返回值，只能用 auto 或 const auto& 或 auto&&
    // 而我们还需要修改 it，所以只能用 auto 或 auto&& 进行引用
    for(auto it = this->lists[h].begin(); it != this->lists[h].end(); ++it)
    {
        // 已经添加过了，我们不能重复添加，所以直接返回
        if((*it) == key)
        {
            return;
        }
    }
    // 没有添加过，我们可以进行添加
    this->lists[h].push_back(key);
}

void Leetcode701_800::Soltuion::MyHashSet::remove(int key)
{
    // 删除值的逻辑本质上和添加是完全一样的
    // 我们同样需要遍历对应的桶来确定要删除的值是否真的存在
    int h = MyHashSet::hash(key);
    for(auto it = this->lists[h].begin(); it != this->lists[h].end(); ++it)
    {
        if((*it) == key)
        {
            // 存在，那么进行删除
            this->lists[h].erase(it);
            return;
        }
    }
    // 否则，没有找到，那么我们直接返回即可
}

bool Leetcode701_800::Soltuion::MyHashSet::contains(int key)
{
    // 检查某个值是否存在，也非常简单
    int h = MyHashSet::hash(key);
    for(auto it = this->lists[h].begin(); it != this->lists[h].end(); ++it)
    {
        if((*it) == key)
        {
            return true;
        }
    }
    return false;
}