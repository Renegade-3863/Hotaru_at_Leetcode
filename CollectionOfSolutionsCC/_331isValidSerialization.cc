#include "Solution.h"

bool Leetcode301_400::Solution::isValidSerialization(string preorder)
{
    // 虽然不允许重建树，但是我们依然可以用类似递归的方法来切入本题的解法
    // 定义下面的过程：dfs(i) 代表 preorder 从下标 i (注意：一个前序序列化中的每个下标上的值都应该是对应了一个结点的) 开始的合法前序序列长度
    // 那么如何判断以下标 i 开始的子序列中合法的前序部分有多长呢？
    // 我们要做的事情不难
    // 最简单的情况：如果这个下标上是一个 '#'
    // 那么说明这是一个代表空树的子序列，那么可以直接返回1，因为这个序列只能包含一个空结点
    // 否则，当前序列开头有一个结点，那么我们需要检查的就是：它的两个子树的合法前序序列长度
    // 具体地：先从 i+1 开始检查：dfs(i+1) 就是从 i+1 开始的合法前序序列长度
    // 之后，由于我们确定了 [i+1, i+dfs(i+1)] 这部分是合法的前序序列
    // 那么也就相当于确定了左子树的最大有效前序遍历长度
    // 之后，很明显就是要检查右子树
    // 我们就应该从 i+dfs(i+1)+1 开始检查
    // 即：dfs(i+dfs(i+1)+1)
    // 写到这里，注意一点：由于后面这个开始下标有可能超出 preorder 大小(即只有左子树的情况)
    // 所以我们给 dfs 加一个限制条件：
    // if(i >= preorder.size()) return 0;
    // 最后，外层调用，我们只需要检查：
    // dfs(0) 是否等于 preorder.size() 即可
    int n = preorder.size();
    function<int(int)> dfs = [&](int i) -> int 
    {
        // 注意一个额外问题：这个条件如果被触发了，那么我们实际上就已经知道这个前序序列不合法了
        // 因为唯一进入这个函数的方法，只能是上面有某个根结点需要在这里有一个子树的表示，而实际上这里没有，又因为我们是根据最终合法的长度来进行判断，所以这里返回一个1，来反映不合法的长度(长度只可能变长，不可能变短)
        if(i >= n)
        {
            return 1;
        }
        // 注意，本题的分隔符中包含了逗号，我们需要特殊处理逗号
        if(preorder[i] == ',')
        {
            return 1+dfs(i+1);
        }
        if(preorder[i] == '#')
        {
            return 1;
        }
        // 其它的一般情况
        // 由于当前这个数可能不是一位数，我们需要找齐这一个结点上所有的数位后再深入遍历
        int j = i+1;
        while(j < n && preorder[j] != ',')
        {
            ++j;
        }
        int leftLen = dfs(j);
        int rightLen = dfs(j+leftLen);
        // 别忘了加上根结点这一个长度
        return (j-i)+leftLen+rightLen;
    };
    return dfs(0) == n;
}