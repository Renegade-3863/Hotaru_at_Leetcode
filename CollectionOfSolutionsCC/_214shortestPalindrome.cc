#include "Solution.h"

string Leetcode101_200::Solution::shortestPalindrome(string s)
{
    // 限定只能往一个字符串的头部添加新字符，要求求出可以实现的最短的回文字符串
    // 本题是一道很经典的 KMP 模块题
    // 注意到 KMP 的核心原理就在于求出的 next 前缀数组，这个数组的含义就在于：
    // 如果下标 i 处的字符无法匹配，前面有多长的可匹配前后缀
    // 本题可以用类似的方案进行求解
    // 考虑这样的事实：
    // 我们总是可以这样实现一个回文串：
    // 把 s 反序得到 s'，并把 s' 接到 s 的头部
    // 不过这样显然不一定是最短的，我们需要优化掉中间那些本身就是回文部分的内容
    // 举例：abcd -> s' = dcba -> s's = dcbaabcd
    // 显然中间的一对 a 就是可以删掉的，而这个 'a' 恰好是 abcd 这个母串的最长回文前缀
    // 可能上面的例子不是很直观，我们转入更加一般性的讨论：
    // 假设有一个字符串：pq，其中 p 是其回文的前缀(注意：必须首先是前缀，才能讨论是否回文)
    // 那么我们如果把它反转过来，应该会得到 q'p'，其中 q' 是 q 的反转，p' 是 p 的反转
    // 而由于 p 本身是一个回文子串，所以有 p == p'，这就说明这部分是可以直接删掉的，不用接成 q'p'pq 这样的回文关系，可以直接把 p' 和 p 重合
    // 那么我们的任务就很简单了，直接可以转换成求 s 的最长回文前缀，之后把它从 s' 中删掉即可
    // 至于为什么说可以使用 KMP 中求解 next 数组的方案求解这里的最长回文前缀
    // 我们可以这样想，前面的 q'p'pq，中间的两个串是相等的
    // 那么我们如果反过来接：pqq'p'，那不就变成了前缀和后缀相等了吗!!!
    // 所以，我们可以反过来接，接好后利用 KMP 求解处这个大串的 next 数组最后一位结果，并从 s' 中删掉这个长度的后缀再接到 s 前面，就是答案
    // 注意，本题的 KMP findNext 过程我们不能再使用传统 KMP 中的类似优化策略了，因为这里我们要找出的是实际的前缀长度，而不是下一步应该实际检查的字符下标了

    // 实际实现过程中可能还有优化点，不过我们先按这种思路写一版代码
    string tmp = s;
    // 计算出 s'
    reverse(s.begin(), s.end());        
    // 把 s' 和 s 合并起来
    string board = tmp + '#' + s;
    // 至于这里为什么需要中间添加一个 '#' 号，考虑这样的事实：
    // 假设 board 不加星号，组合出来的部分是 bbbb，也就是：s' 和 s 都是 "bb"，那么会有个问题：
    // next 数组找出的最终结果会是 4，也就是它认为，这个子串有长度为4的相等前后缀，那么此时，我们能从 s' 中删掉长度为4的后缀吗？
    // 显然不能，因为 s' 的长度甚至只有2！
    // 所以我们需要添加一个永远不可能匹配的字符，也就是这里的 '#'，来截断 next 数组，不让它越过 s' 的原长
    // 剩下的部分就是基本的 findNext 函数了
    vector<int> next(board.size()+1, 0);
    int j = 0, k = -1;
    next[0] = -1;
    // 再次回顾 k 值的含义：当前 j 位置处形成的前缀子串本身的真前缀长度
    // 真前缀的意义是：abab，这里如果 j == 3，那么真前缀就是 (a)b(a)b 而不是 (ab)(ab)
    while(j < board.size())
    {
        // j 的当前字符已经没有可以匹配的前缀了，或者它已经找到了可以匹配的前缀，我们都可以跳过它的内容计算了
        if(k == -1 || board[j] == board[k])
        {
            // 移动 j 指针，跳过当前位置的计算，并更新对应的 k 值
            ++j; ++k;
            next[j] = k;
        }
        // 不能匹配，那么我们显然没法移动 j 值，反而需要回弹 k 值，找上一个可能可以匹配 board[j] 的字符进行比较
        // 也就是说，j+1 这个位置处的真前缀不是 board[0..k] 这个前缀，应该继续向前回溯寻找能跟 board[j] 匹配的字符
        else
        {
            k = next[k];
        }
    }
    // 结束后，我们就计算完成了整个 next 数组，可以进行后续处理了
    // 实际上我们只需要 next[board.size()] 这一个值做后续计算
    s = s.substr(0, s.size()-next[board.size()]);
    tmp = tmp + s;
    return tmp;
}