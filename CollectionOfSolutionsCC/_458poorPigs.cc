#include "Solution.h"

int Leetcode401_500::Soltuion::poorPigs(int buckets, int minutesToDie, int minutesToTest)
{
    // 一道基于 "香农公式" 的数学题，理解和最优证明都属于 top 级别的理解难度了，不过个人认为是很值得了解的一个决策问题，生活中也可能会用到
    // 我们首先思考最简单的情况：
    // 如果我们要测 buckets 桶水，而时间只够测一轮，那么最少需要多少只猪？
    // 基于信息论的一些奇妙想法，数学家们给出了这样的信息编码方式：
    // 假设最终有毒的那一桶水的实际编号为 k，(0 <= k < n) (n 为水桶的总个数)
    // 那么它一定会对应一个二进制数 (到这一步听不懂的建议回去重学计算机。。)
    // 接下来，我们利用类似 "数位 dp" 的方式，逐位地确定这个有毒编号的每一个二进制位
    // 具体做法是：假设表示这个序号需要 j 位二进制位，那么我们一共就需要 j 只猪
    // 让每只猪喝一些桶水
    // 比如第一只猪，在唯一轮中喝那些二进制表示中最低位为 1 的桶中的水
    // 第二只猪，在唯一轮中喝那些二进制表示中第二低位为 1 的桶中的水
    // 以此类推
    // 只要某只猪在这一轮死了，那么我们就可以明确知道：最后有毒的那个桶序号的二进制表示中，对应这只猪的位上的值为 1，而不是 0
    // 这样，我们通过每一位上的猪的生死情况，就能推算出最后的桶的序号了！
    // 推广到多轮测试的情况，实际上类似
    // 我们依然从实际的进制表示来看这个推广问题：
    // 我们假设，可以最多测 m 轮，那么是不是用 (m+1) 进制数表示 n 就可以了？
    // 想一下：最后有毒的那桶水一定也会对应一个 (m+1) 进制数，而这个进制数，同样可以用 "n 的 (m+1) 进制表示形式长度" 那么多只猪来按位求解！
    // 那么实际上，需要的最少猪的个数就可以通过一个简单的数学公式求出来：
    // (m+1)^x >= buckets && (m+1)^(x-1) < buckets，这里的 x 就是答案
    // 转换一下，就是：x >= log(m+1)(buckets)
    // 到这里，我们不可否认这是一个很不错的求解方法，但是它求出来的 x 是最小的吗？
    // 具体的证明就涉及到香农公式了，这里限于本人数学能力问题，就不具体写出证明过程了，详见 Leetcode 各大神的证明逻辑～
    // 求出底数 m+1
    int base = (minutesToTest/minutesToDie)+1;
    // 注意向上取整
    return ceil(log(buckets)/log(base)-1e-5);
}