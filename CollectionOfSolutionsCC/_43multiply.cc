#include "Solution.h"

string Leetcode1_100::Solution::multiply(string num1, string num2)
{
    // 要求实现一个函数，这个函数能够执行两个以字符串形式表示的非负整数 num1 和 num2 相乘的结果，结果也用字符串的形式表示
    // 如果之前实现过大数求和的算法，这里其实会觉得有迹可循
    // 我们可以使用和大数求和相似的算法进行进位的延后计算
    // 首先，对于两个数相乘的结果，假设 num1 有 m 位数，num2 有 n 位数
    // 我们可以用一个整数数组存放每两位乘积的累加和
    // 额外的情况，如果两个数中至少有一个是 0，那么我们下面的算法逻辑会搞出来一个长度不为1的零序列，这样答案会有问题，因而我们需要在这里做一个特判
    if(num1 == "0" || num2 == "0")
    {
        return "0";
    }
    int m = num1.size(), n = num2.size();
    vector<int> partial(m+n, 0);
    // 这个数组用来执行类似竖式计算中的对应位的最终结果(不进位)，记录完成后对其遍历进行进位计算即可
    // 建立一个两数数位下标和它们相乘结果存储的结果的下标之间的映射
    // num1[i]*num2[j] -> 对应的是 partial[i+j+1]
    // 这里可以稍微解释一下上面 partial 数组需要存 m+n 个下标的原因
    // 考虑 num1[m-1] 与 num2[n-1] 相乘
    // 此时这个结果应该存储在 partial[m+n-2] 中，所以 partial 至少需要有 m+n-1 个位置
    // 之所以多存储一位，是因为这最高的两位相乘的结果，或者后续执行进位之后的结果，会溢出到更高的一位，所以这里多保留一个位置给可能的高位进位
    // 又由于我们计算的时候是从高位向低位计算，故在最高位会需要保留这个最终的进位，因而在进行映射的时候就是 i+j+1 而不是 i+j 了
    // 如果希望映射的理解难度更低，可以优化一下我的这个映射方法，不过我这种映射也是正确的
    // 明确了基础设置，后面的算法逻辑就和大数相乘几乎一致了，只不过多了把加法运算换成了乘法运算而已
    for(int i = 0; i < m; ++i)
    {
        for(int j = 0; j < n; ++j)
        {
            // 求出两个对应位置上数字的乘积
            int mult = (num1[i]-'0') * (num2[j]-'0');
            // 录入到对应的位置上
            partial[i+j+1] += mult;
        }
    }
    // 结束后，partial 的对应位置上存放的就是距离最终结果只差一步遍历求进位步骤的结果值了
    // 进行进位流程即可
    // 注意进位是从低位到高位，我们这里存放的是一个倒序的结果，所以遍历的时候要从后向前检查
    for(int i = m+n-1; i > 0; --i)
    {
        int carry = partial[i] / 10;
        partial[i] %= 10;
        partial[i-1] += carry;
    }
    // 最后，把 partial 中记录的每一个数字按顺序录入到一个 string 中作为结果即可
    string res = "";
    for(int i = 0; i < m+n; ++i)
    {
        if(i == 0 && partial[i] == 0)
        {
            continue;
        }
        res += char(partial[i]+'0');
    }
    return res;
}