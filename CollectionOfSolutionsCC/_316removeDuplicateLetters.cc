#include "Solution.h"

string Leetcode301_400::Solution::removeDuplicateLetters(string s)
{
    // 其实可以算是一个简单的栈问题
    // 思考
    // 我们可以通过这样的方式：
    // 保存一个存储了 s 中到目前为止可以知道的去除了重复字符的最小字典序字符串
    // 之后在逐步向后遍历的过程中更新这个栈
    // 如何更新？
    // 首先，我们知道，前面的部分是按顺序检查下来，满足题意(字典序最小)的部分
    // 那么我们实际上需要检查的只有这个栈顶部的元素和当前的元素
    // 这两个元素之间无非有以下几种关系
    // 1. 栈是空的，没有顶部元素
    // 此时我们只需要把当前元素添加到栈中即可
    // 2. 栈非空
    // 2.1 栈顶部元素在字母顺序角度是小于当前元素的
    // 那么我们也可以直接压入当前元素，因为这不会影响前面已经满足了最小字典序的无重复字符串
    // 2.2 栈顶部元素在字母顺序角度是大于当前元素的
    // 那么我们需要进一步细分
    // 2.2.1 当前栈顶元素在当前元素后面还有剩余
    // 那么很显然我们可以把这个栈顶元素先弹出栈，并重复这个条件判断
    // 直到栈为空或者栈顶元素不大于当前元素的其它情况
    // 2.2.2 当前栈顶元素在当前元素后面已经没有剩余了
    // 那么我们没法弹出这个更大的元素，只能保留它，而对于当前字符，如果我们在前面的序列中已经添加过了这个较小的字符，那么很明显我们不再需要重复添加这个字符
    // 这里的 "添加过" 检查还是需要一个哈希集合来进行记录
    // 重复上面的整体逻辑直到遍历完整个字符串
    // 记录所有添加过的字符
    unordered_set<char> added;
    // 用一个哈希表存储这个 s 字符串中每种字符出现的次数
    unordered_map<char, int> cnts;
    int n = s.size();
    // 先进行一轮预处理
    for(int i = 0; i < n; ++i)
    {
        ++cnts[s[i]];
    }
    // 用字符串模仿一个栈
    string res = "";
    for(int i = 0; i < n; ++i)
    {
        // 如果这个字符前面已经添加过了，那么我们不能进行第二轮添加
        if(added.find(s[i]) != added.end())
        {
            // 修改剩下的字符计数
            --cnts[s[i]];
            continue;
        }
        // 否则，当前字符前面没添加过，我们可以进一步探讨
        // 循环检查栈顶元素和当前元素的关系
        while(!res.empty() && res.back() > s[i] && cnts[res.back()])
        {
            // 修改添加过记录，把栈顶元素弹出
            added.erase(res.back());
            res.pop_back();
        }
        // 因为能执行到这里，当前字符一定是没有添加过的新字符，并且顶部元素是小于当前字符的，或者结果串根本就是空的，此时我们直接将其添加即可
        res.push_back(s[i]);
        // 修改当前字符的剩余个数
        --cnts[s[i]];
        // 记录当前字符已经添加过
        added.insert(s[i]);
    }
    // 直接返回结果即可
    return res;
}
