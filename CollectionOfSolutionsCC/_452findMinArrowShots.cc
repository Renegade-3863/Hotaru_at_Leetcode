#include "Solution.h"

int Leetcode401_500::Soltuion::findMinArrowShots(vector<vector<int>>& points)
{
    // 本题是一道经典的贪心类问题，我们按贪心的角度进行切入即可
    // 一个简单的想法：如果我们能让每一支箭都尽可能多的击中最多的气球，那么是不是就能实现使用最少数量的箭的目标？
    // 我们如何做到让每一支箭都尽可能的击中最多的气球呢？
    // 我们需要用一支新箭的条件是：遇到一个新的，不能和它前面的气球一起被击破的气球，这种时候，我们就不得不引入一支新箭了
    // 那么一个气球，什么时候可以和前面的气球一起被击破呢？
    // 很显然的一个条件：当前气球的左边界 <= 之前某个气球的右边界
    // 所以我们可以自然地想到一种解法：
    // 对所有气球按右边界排好序
    // 之后，遍历所有气球
    // 只有当前这个气球的左边界和前面所有气球的右边界都没有重叠的时候，我们才需要引入一支新箭来射爆它
    // 而在前面的排序中，我们已经把所有气球都按右边界排好序了，所以我们实际上只需要检查上一个区间的右边界即可
    // 论证一下这个方法的正确性：
    // 我们尝试用一下数学归纳法：
    // 首先，假设只有一个气球，那么我们用这个气球的右边界作为基准，发现必须用一支新箭来射爆它，此时答案正确，为一支箭
    // 之后，假设现在有 k 个气球，我们需要最少 f(k) 支箭来把它们射爆
    // 考虑一个新的，右边界比前面这 k 个气球都大的新气球
    // 那么无非两种情况：
    // 1. 这个新气球可以和前面的所有气球一起被射爆
    // 2. 这个新气球不能和前面的所有气球一起被射爆
    // 我们不难发现，这两种情况的分界点就是我们上文提到的左边界和右边界的不相交点
    // (注意：我们的假设是：每一支箭，都射在某个气球的右边界上)
    // 这就满足了，只有当这个新气球不能和前面所有气球一起被射爆的时候，我们才使用一支新箭，否则不用新箭，用和之前一样最少的箭就够了
    // 论证完毕，写代码就很简单了
    // 首先对 points 数组按照第二维进行重新排序，注意到，右边界相等的情况，我们实际上不用做任何特殊处理
    sort(points.begin(), points.end(), [&](const vector<int>& a, const vector<int>& b) -> bool {
        return a[1] < b[1];
    });
    // 之后就是 O(n) 的遍历了
    // 因为至少有一个气球，我们的预设可以简单一些，不用考虑没有气球的特殊情况
    // last 代表的是最近一支箭射出的坐标，这里第一支箭就是 point[0][1] 位置处射出的
    int res = 1, last = points[0][1], n = points.size();
    for(int i = 1; i < n; ++i)
    {
        // 把 points[i][0] 与 last 进行比较，必要时更新 last
        if(points[i][0] > last)
        {
            last = points[i][1];
            ++res;
        }
    }
    return res;
}