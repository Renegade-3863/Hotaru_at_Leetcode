#include "Solution.h"

int Leetcode1_100::Solution::mySqrt(int x)
{
    // 给定一个整数 x，要求我们找出对应这个值 x 的平方根(保留整数)
    // 最朴素的算法肯定是从大到小遍历所有不大于 x 的正整数，对每一个遍历到的值做平方，直到找到第一个平方结果小于 x 的值
    // 这种 brute-force 算法的复杂度是 O(n) 并不那么令人满意，而且如果 x 的值比较大，甚至有可能会整形溢出
    // 思考：2147483646 * 2147483646 = ? 肯定大于 2147483647 了
    // 那么如何做到既降低复杂度，又避免溢出呢？
    // 首先，提到比 O(n) 还低的时间复杂度，一般能想到的也就只有 O(logn) 的二分法了，本题符合二分性质吗？
    // 显然是符合的
    // 注意到，我们可以对整个不大于 x 的整数区间进行二分
    // 每次取中间的那个值 (x>>1) (或者 ((x-0)>>1)+0)
    // 看这个值做平方是否是小于 x 的
    // 如果是，那么当前这个中间值可以作为备选答案，我们可以记录这个值作为备选的答案
    // 而且所有小于 (x>>1) 的值都不可能是答案了
    // 否则，如果 (x>>1)*(x>>1) == x，那么这个 (x>>1) 就是答案，直接返回即可
    // 否则，那么当前这个值，以及所有比 (x>>1) 大的元素也都不可能是答案了
    // 这就很好地契合了二分的性质
    // 再考虑溢出问题
    // 我们可能会拿到的最大的要进行平方计算的值是 (2147483647>>1)，这个值也就是 (2^31-1)/2
    // 它做平方的结果是：(2^31-1)^2/4
    // 这个值很显然也会溢出
    // 那么我们其实可以用另一种方式，不是乘法，而是除法(就是类似我们之前写除法算法的时候用来避免溢出的方案)来进行大小判断
    // 例如 mid*mid > INT_MAX，我们用 INT_MAX / mid < mid 来进行判断即可
    // 最后，注意到 mid*mid > INT_MAX 其实就和 mid*mid > x 的效果是一样的，因为已知 x 是属于 [0, INT_MAX] 的
    int left = 0, right = x;
    int res = -1;
    // 特殊情况，用我们下面的条件做判断，在 x == 0 或者 x == 1的时候会报 "division by zero" 错误，需要特殊处理
    if(x == 0 || x == 1)
    {
        return x;
    }
    while(left <= right)
    {
        int mid = ((right-left)>>1)+left;
        if(mid > INT_MAX/mid || mid*mid > x)
        {
            right = mid-1;
        }
        else if(mid*mid == x)
        {
            return mid;
        }
        else
        {
            res = mid;
            left = mid+1;
        }
    }
    // 应该认识到，结果一定存在，所以我们直接返回结果即可
    return res;
}