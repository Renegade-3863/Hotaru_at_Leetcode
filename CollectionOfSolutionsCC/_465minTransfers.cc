#include "Solution.h"

// 基本的暴力 DFS 算法，甚至无法通过测试的第一个案例就 TLE 了
int Leetcode401_500::Soltuion::minTransfers(vector<vector<int>>& transactions)
{
    // 如果这道题面试的时候考，我只能说，与其花时间想怎么做，不如扇面试官一巴掌。。
    // 本质还是一道 DP 类型的题，不过是最难想的状态压缩 DP，而且这个状态思考本身也很反人类
    // 本题的子问题定义是这样的：
    // 假设当前考虑的参与者序号用一个整数 i 表示，i 的二进制中对应位为 1 的下标代表的人我们称其为 "参与者"
    // 我们考虑的是，有这些参与者，以及他们对应的净资产的情况下，最少所需的交易次数。
    // 根据这个定义，那么我们所需求解的最大子问题，就是一个全 1 的 i，这个 i 中从最低位开始连续 1 的长度就等于所有存在的参与者总人数，我们假设本题的参与者人数为 n 人
    // 这个定义如何递推？DP 问题都会需要找出一个可行的由子问题递推出母问题的逻辑关系式
    // 我们可以这样思考对整个集合的处理流程：
    // 无论如何，我们总需要先处理当前选择的参与者中一部分人之间的净资产，把它们的净资产清零，之后再把另一部分人的净资产也清零，最后达成全部清零的结果
    // 所以，实际上，对于已知的 i，我们需要做的是，拆分 "把 i 这种子集的所有人的净资产全部清空为0" 成 "把 j (j 是 i 的子组分) 这种子集的所有人的净资产全部清空为0 与 把 i^j (i^j 是 j 对于 i 的补集) 子集的所有人的净资产全部清空为0"
    // 从代码角度，子问题定义以及递推式可以写作：
    // dfs(i)：代表，参与者状态为 i 时，最少需要的交易次数
    // dfs(i) = min(dfs(i), dfs(j)+dfs(i^j))，对于所有 i 的子集 j，同时 j 选中的所有参与者的净资产和为 0，也就是这些人的净资产可以完成交换达到全零
    // 我们只需要在代码中考虑如何更快地完成子集的拆分即可
    // 子问题函数，传入一个当前的状态子集 i，我们对这个 i 进行处理
    // n 是最多的参与者人数，本题限制了最多12个参与者，所以我们定义一个常量 n == 1
    const int n = 12;
    // 我们定义一个 cnt 数组，记录当前每个参与者持有的净资产
    // 初始化为全零
    int cnt[n] = {0};
    // 之后按照所有的交易计算出实际的净资产值
    for(auto& transaction : transactions)
    {
        cnt[transaction[0]] -= transaction[2];
        cnt[transaction[1]] += transaction[2];
    }
    function<int(int)> dfs = [&](int i) -> int
    {
        // 需要定义出一个基本的情况，也就是 i == 0
        // i == 0 时，我们很明显知道，这个子集不需要任何交易就已经平衡了
        if(i == 0)
        {
            // 直接返回 0 即可
            return 0;
        }
        // 否则，我们需要先检查当前划分代表的所有人的净资产和，只有所有人的净资产和为零，我们才能进一步划分更小的子问题进行求解
        // 记录当前 i 划分的所有人净资产和
        int sum = 0;
        for(int j = 0; j < n; ++j)
        {
            if(((i >> j) & 1))
            {
                // cout << cnt[j] << endl;
                // 如果下标为 j 的参与者被这个划分选中了，那么我们累加它现在的净资产到 sum 中
                sum += cnt[j];
            }
        }
        // 计算完成，我们需要确保 sum 为零，只有这样，我们的这个划分才有可能完成独立的自归零操作
        if(sum)
        {
            // sum 非零，我们返回一个极大值，例如 INT_MAX / 2，代表划分不合法
            return INT_MAX / 2;
        }
        // sum 为零，那么我们可以继续细分这个子集，进行下一步的处理
        // 我们需要枚举 i 的所有可能二分
        // 默认的最多交易次数为：只有一个正数，所有其他人都欠这个正数钱，此时需要的交易次数是最多的，也就是 i 的二进制表示中 1 的个数 -1 次
        // 我们根据这个值对 res 进行初始化即可
        int res = __builtin_popcount(i)-1;
        // 之后就是枚举 i 的所有可能二分，计算出最小的二分结果
        for(int j = (i-1)&i; j > 0; j = (j-1)&i)
        {
            res = min(res, dfs(j)+dfs(i^j));
        }
        return res;
    };
    // 子问题定义完成，我们只需要调用即可，最大的子问题就是 dfs((1 << 12) - 1)
    return dfs((1<<12)-1);
}

// 考虑使用记忆化数组记住过程结果
int minTransfers(vector<vector<int>>& transactions)
{
    // 如果这道题面试的时候考，我只能说，与其花时间想怎么做，不如扇面试官一巴掌。。
    // 本质还是一道 DP 类型的题，不过是最难想的状态压缩 DP，而且这个状态思考本身也很反人类
    // 本题的子问题定义是这样的：
    // 假设当前考虑的参与者序号用一个整数 i 表示，i 的二进制中对应位为 1 的下标代表的人我们称其为 "参与者"
    // 我们考虑的是，有这些参与者，以及他们对应的净资产的情况下，最少所需的交易次数。
    // 根据这个定义，那么我们所需求解的最大子问题，就是一个全 1 的 i，这个 i 中从最低位开始连续 1 的长度就等于所有存在的参与者总人数，我们假设本题的参与者人数为 n 人
    // 这个定义如何递推？DP 问题都会需要找出一个可行的由子问题递推出母问题的逻辑关系式
    // 我们可以这样思考对整个集合的处理流程：
    // 无论如何，我们总需要先处理当前选择的参与者中一部分人之间的净资产，把它们的净资产清零，之后再把另一部分人的净资产也清零，最后达成全部清零的结果
    // 所以，实际上，对于已知的 i，我们需要做的是，拆分 "把 i 这种子集的所有人的净资产全部清空为0" 成 "把 j (j 是 i 的子组分) 这种子集的所有人的净资产全部清空为0 与 把 i^j (i^j 是 j 对于 i 的补集) 子集的所有人的净资产全部清空为0"
    // 从代码角度，子问题定义以及递推式可以写作：
    // dfs(i)：代表，参与者状态为 i 时，最少需要的交易次数
    // dfs(i) = min(dfs(i), dfs(j)+dfs(i^j))，对于所有 i 的子集 j，同时 j 选中的所有参与者的净资产和为 0，也就是这些人的净资产可以完成交换达到全零
    // 我们只需要在代码中考虑如何更快地完成子集的拆分即可
    // 子问题函数，传入一个当前的状态子集 i，我们对这个 i 进行处理
    // n 是最多的参与者人数，本题限制了最多12个参与者，所以我们定义一个常量 n == 1
    const int n = 12;
    // 我们定义一个 cnt 数组，记录当前每个参与者持有的净资产
    // 初始化为全零
    int cnt[n] = {0};
    // 之后按照所有的交易计算出实际的净资产值
    for(auto& transaction : transactions)
    {
        cnt[transaction[0]] -= transaction[2];
        cnt[transaction[1]] += transaction[2];
    }
    // 定义一个记忆化数组 dp
    // 原值 -1 代表还未知道结果
    vector<int> dp(1<<n, -1);
    function<int(int)> dfs = [&](int i) -> int
    {
        // 记忆化调用
        if(dp[i] != -1)
        {
            return dp[i];
        }
        // 需要定义出一个基本的情况，也就是 i == 0
        // i == 0 时，我们很明显知道，这个子集不需要任何交易就已经平衡了
        if(i == 0)
        {
            // 直接返回 0 即可
            return 0;
        }
        // 否则，我们需要先检查当前划分代表的所有人的净资产和，只有所有人的净资产和为零，我们才能进一步划分更小的子问题进行求解
        // 记录当前 i 划分的所有人净资产和
        int sum = 0;
        for(int j = 0; j < n; ++j)
        {
            if(((i >> j) & 1))
            {
                // cout << cnt[j] << endl;
                // 如果下标为 j 的参与者被这个划分选中了，那么我们累加它现在的净资产到 sum 中
                sum += cnt[j];
            }
        }
        // 计算完成，我们需要确保 sum 为零，只有这样，我们的这个划分才有可能完成独立的自归零操作
        if(sum)
        {
            // sum 非零，我们返回一个极大值，例如 INT_MAX / 2，代表划分不合法
            dp[i] = INT_MAX / 2;
            return dp[i];
        }
        // sum 为零，那么我们可以继续细分这个子集，进行下一步的处理
        // 我们需要枚举 i 的所有可能二分
        // 默认的最多交易次数为：只有一个正数，所有其他人都欠这个正数钱，此时需要的交易次数是最多的，也就是 i 的二进制表示中 1 的个数 -1 次
        // 我们根据这个值对 res 进行初始化即可
        int res = __builtin_popcount(i)-1;
        // 之后就是枚举 i 的所有可能二分，计算出最小的二分结果
        for(int j = (i-1)&i; j > 0; j = (j-1)&i)
        {
            res = min(res, dfs(j)+dfs(i^j));
        }
        dp[i] = res;
        return dp[i];
    };
    // 子问题定义完成，我们只需要调用即可，最大的子问题就是 dfs((1 << 12) - 1)
    return dfs((1<<12)-1);
}

// 转换成自底向上的 DP 方法
int minTransfers(vector<vector<int>>& transactions)
{
    
}