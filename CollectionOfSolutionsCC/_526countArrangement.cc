#include "Solution.h"

int Leetcode501_600::Soltuion::countArrangement(int n)
{
    // 首先，对于这种排列组合类的题目，我们最简单暴力的解法应该都是回溯，不过本题可以针对回溯进行优化
    // 这一点我们后面讨论转换为 DP 时具体说
    // 我们使用回溯的方式，暴力枚举最后排列的每一个位置上的元素值
    // 定义一个 backtrack 函数
    // backtrack(idx)，代表尝试把 idx 这个值放到当前结果排列结尾处的操作
    // 保存一个回溯数组，存储 "当前结果排列"
    vector<int> path;
    // 注意，需要一个结构来记录我们当前已经用了哪些值，题目限定了 1 <= n <= 15，那么我们可以用一个整数值来记录
    // 初始，所有位都是 0，代表没有元素被放到结果数组中过
    int visited = 0;
    int res = 0;
    function<void(int)> backtrack = [&](int idx) -> void
    {
        // 检查 path 的长度，这个长度值就是 idx 这个值要放到的位置下标
        // 1. 如果 path.size() == n，那么我们已经填完了一组排列，对全局的记录值加 1 即可
        if(path.size() == n)
        {
            ++res;
            return;
        }
        // 2. 否则，尝试把一个没有添加过的元素放到 path.size() 这个位置上
        for(int i = 1; i <= n; ++i)
        {
            // 如果 i 这个值不满足题目的要求，就跳过它
            if((path.size()+1) % i && i % (path.size()+1))
            {
                continue;
            }
            if((visited >> (i-1)) & 1)
            {
                // 如果对应位是 1，说明这个元素已经用过了，我们直接跳过它
                continue;
            }
            // 递归
            path.push_back(i);
            // 记录 i 这个元素用过了
            int tmp = visited;
            visited = visited | (1 << (i-1));
            backtrack(i+1);
            // 回溯
            visited = tmp;
            path.pop_back();
        }
    };
    // 调用上面的函数即可，注意，初始调用参数应该是 1，代表第一次尝试填 1 
    backtrack(1);
    return res;
}

// 简单暴力的回溯 -> 尝试进行 DP 优化
// 回顾我们前面做过的几百道题目，我们会发现，一般涉及到 "找出所有结果" 的提问，我们都必须要用回溯暴搜来遍历所有可能的结果
// 而能优化成 DP 的 DFS，一般都是 "找出最优解个数" 这种要求的题目
// 本题也不例外
// 题目要求的是 "优美排列的数量"，所以也是一道 "只求个数，不求细节" 的题目
// 我们尝试定义一下子问题的解
// 回顾上面的暴搜过程，我们可以发现，在每一轮内部遍历中，我们实际上都会检查到很多重复的解
// 比如 "当前已经用过某些数据 (保存在 visited 值中) 的情况下，我们继续向后进行检查"
// 我们会发现，前面这些用过的数据 
/*
    举个例子：
    {1, 3, 7, 2}
    {3, 1, 2, 7}
    ...
    这些情况都属于："前面用过了 {1, 2, 3, 7} 这个集合中的数据" 的情况
*/  
// 而后面我们在继续检查的时候，并不会关心前面这个集合里面具体用了哪些元素
// 所以我们实际上可以进行记忆化：记住 "用过哪些元素时，剩下的元素可以构成多少种优美排列"
// 这样，子问题就定义完成了
// 我们形式化一个这样的子问题：
// dfs(S)，代表已经用过的数据集为 S 的情况下，剩下的元素可以构成的 "优美排列个数"
// 那么很明显，我们需要的最终问题就是 dfs(0)
int countArrangement(int n)
{
    // 由于题目限定了 1 <= n <= 15，和第一种方案一样，我们可以使用一个整数来代替集合
    // visited 记录 "当前访问过的元素"
    // 对应 n 个元素，应该有 2^n 种选取的情况，所以我们开一个 2^n 的数组来保存这些状态的结果信息
    // -1 代表这种状态还没检查过
    vector<int> memo(1<<n, -1);
    function<int(int)> dfs = [&](int status) -> int
    {
        // 定义一个基本情况，当 status == (1<<n)-1 的时候，说明我们已经选取了所有元素到集合中，没有剩下的元素
        // 而不用任何元素，只能构造出一种排列：就是空排列，所以此时我们返回 1
        if(status == (1<<n)-1)
        {
            return 1;
        }
        // 这个函数用于检查 status 状态下，可以构成的 "优美的排列" 个数
        if(memo[status] != -1)
        {
            // 已经记录过对应结果了，我们直接返回记录的结果即可
            return memo[status];
        }
        // 否则，没有记录过，我们考虑如何从子问题进行递推
        // 考虑枚举不属于 status 表示的集合中的每一个元素 j，如果它可以满足 "放到对应位置上可以被下标整除/下标可以被它整除"
        // 那么就累加一次 status U {j} 的结果 (因为我们用了 status U {j} 这个集合中的元素，剩下的就是一个子问题了)
        int res = 0;
        for(int i = 1; i <= n; ++i)
        {
            // 如果 i 不属于 status，我们才进行尝试
            if((status >> (i-1)) & 1)
            {
                continue;
            }
            // 注意：status 代表的数组大小可以告诉我们 i 此时要被放到的下标位置，我们可以用位运算的方式获取 status 数中 1 的个数
            int idx = __builtin_popcount(status)+1;
            if(idx % i == 0 || i % idx == 0)
            {
                // i 值可行
                // 更新 status
                int tmp = status;
                status = status | (1<<(i-1));
                // 递归
                memo[status] = dfs(status);
                res += memo[status];
                // 回溯
                status = tmp;
            }
        }
        return res;
    };  
    return dfs(0);
}