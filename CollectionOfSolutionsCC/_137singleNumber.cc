#include "Solution.h"

int Leetcode101_200::Solution::singleNumber2(vector<int>& nums)
{
    // 本题相对 136 题，做了一些难度加强，可以推广成：除了一个元素只出现一次外，其余每个元素都出现奇数次，要求找出只出现了一次的那个元素
    // 还是那句话，本题通过哈希表的朴素方案依然可以简单解决，但是我们依然想优化这个空间复杂度
    // 依然是考虑位运算
    // 此时上一题的规律显然不再适用
    // 因为：
    // (((a ^ b) ^ b) ^ b) = a ^ b
    // 那么如何求解？
    // 转换一下思路，考虑所有这些数的二进制表达形式
    // 例如：[2, 2, 3, 2]
    // 列出来是
    /*
        0010
        0010
        0011
        0010
    */
    // 我们不难发现，因为只要重复的数字都会出现三次，那么假设没有这个单独出现一次的数字，那么最后对应位上出现的 1 的个数一定是三的倍数
    // 而现在有了这个单独的元素，我们会发现每个位上 1 出现的次数不一定是三的倍数了
    // 因而我们可以对每一位上出现 1 的次数对 3 取模，得到的结果不就是 单独的那一个数字对应的二进制表示中这一位上 1 出现的次数了吗？
    // 很巧妙的思路，会消耗 O(32n) 的复杂度
    // 我们可以很容易地写出代码：
    // res 记录的是只出现一次的数字
    int n = nums.size(), res = 0;
    for(int i = 0; i < 32; ++i)
    {
        // 记录所有数字对应位上1的个数和
        int cnt = 0;
        for(int j = 0; j < n; ++j)
        {
            cnt += ((nums[j] >> i) & 1);
        }
        res |= (1 << i) * (cnt % 3);
    }
    return res;
}