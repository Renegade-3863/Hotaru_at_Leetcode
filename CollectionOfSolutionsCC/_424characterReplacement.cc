#include "Solution.h"

int Leetcode401_500::Solution::characterReplacement(string s, int k)
{
    // 第一眼看有点滑动窗口的样子，因为要求的是一个最多可以接受 K 次修改的最长子串
    // 我们需要做的就是：维护一个窗口中所有不同种字符各自出现的次数哈希表
    // 之后，动态维护所有出现的字符种类中出现次数最多的那一种，因为根据贪心的思想，一个窗口要想修改的字符个数最少，肯定需要把所有其它字符都改成窗口中出现次数最多的那一种字符
    // 根据上面的中心思想，我们还是使用 "以下标 i 为结束点的最长合法子串" 来对问题进行求解
    // 依然定义两个指针，一个 left，一个 right
    int left = -1, n = s.size();
    // 用一个哈希表记录当前窗口中每一种字符出现的次数
    unordered_map<char, int> memo;
    // 记录出现出现次数最多的字符的数量
    int times = 0;
    // 用于记录出现次数最多的那种字符
    char rec;
    int res = 0;
    for(int right = 0; right < n; ++right)
    {
        // 每一轮循环，我们都保证计算出对应结尾的窗口合法结果
        // 更新当前新字符的出现次数
        if(++memo[s[right]] > times)
        {
            // 如果这个更新后的字符出现的次数多于了我们已知的最大出现次数，那么我们就更新 times 变量
            times = memo[s[right]];
            rec = s[right];
        }
        // 如果当前的窗口中需要删掉的字符个数还没超过 k 个，那么我们直接更新最长窗口长度即可
        // 否则，我们需要不断向右移动左指针，直到我们把需要删除的字符总数控制到 k 个及以内
        // 循环的退出条件为：
        // 窗口中需要删除的字符个数不超过 k 个了
        // 注意，每一轮内部循环过后，times 都是有可能被修改的，left 也是会被修改的
        while(right-left-times > k)
        {
            // 每次，我们删除掉窗口左边界上的这个字符 s[left+1]
            // s[left] 可能有几种不同情况，
            // 1. s[left+1] 就是 rec 记录的这种出现次数最多的字符
            // 此时我们需要额外进行检查：遍历整个哈希表，更新当前出现次数最多的字符以及出现次数
            // 2. s[left+1] 不是 rec 记录的这种出现次数最多的字符
            // 那么不需要任何进一步检查，因为我们修改了 left 的值就足够了
            // 删掉开头的字符
            --memo[s[left+1]];
            // 对应情况1. 我们删掉的是一个原本出现次数最多的字符
            if(s[++left] == rec)
            {
                int newTimes = 0;
                // 那么就需要对整个哈希表进行遍历，确认现在窗口中出现次数最多的那种字符，更新给 times 和 rec 变量，以供后续计算
                for(const auto& p : memo)
                {
                    if(p.second > newTimes)
                    {
                        newTimes = p.second;
                        rec = p.first;
                    }
                }
                times = newTimes;
                // 维护完成，可以进行下一步操作
            }
            // 对应情况2. 我们删掉的是一个其它类型的字符
            // 那么此时什么都不需要做，因为我们只需要修改 left，而已经修改完成了
        }
        // 循环退出后，我们就拿到了以 s[right] 结尾的最长的，至多需要修改 k 次的子串
        // 更新答案即可
        res = max(res, right-left);
    }
    return res;
}