#include "Solution.h"

int Leetcode201_300::Solution::findCelebrity(int n)
{
    // 从最基本的方法开始入手
    // 最暴力的办法是，把每个人抽象成一个结点，然后通过 O(n^2) 次问询，具体来说，是 (n-1)*n 次问询，确认每个人和其它 n-1 个人之间的关系
    // 我们只需要在问询的过程中记录是否出现过一个入度为 n-1，出度为 0 的结点即可
    // 不过进阶问题要求我们找出检查次数不超过 3n 次的方案
    // 所以需要考虑优化解法
    // 考虑这样的问题：
    // 我们在使用 knows API 问询的时候，无非有两种可能的结果
    // 1. a knows b == true，代表 a 认识 b
    // 此时我们还能知道什么信息？
    // 我们显然知道：a 不可能是 "名人"
    // 根据 "名人" 的定义，因为 a 认识了至少一个其他人，那么他就不可能是 "名人" 了
    // 因而我们就不用继续针对 a 进行问询了，可以继续对 b 进行问询
    // 2. a knows b == false，代表 a 不认识 b
    // 此时我们还能知道什么信息？
    // 我们显然知道：b 不可能是 "名人"
    // 根据 "名人" 的定义，因为 b 没有被所有其他人认识，那么他就不可能是 "名人" 了
    // 因而我们就不用检查 b 了，而应该继续对 a 进行问询
    // 根据题目的限制，我们可以确信这样一定可以最终定位到一个可能为 "名人" 的人，并且一定只有一个这样的人
    // 因为题目限制了最多只可以有一个 "名人"
    // 写代码无非就是在模拟上面的过程
    // 定义一个 "名人候选人"，初始值为 0，代表我们最初假设 0 号人物可能是 "名人"
    int candidate = 0;
    // 之后不断通过 knows API 进行问询
    // 注意，由于我们每一次问询，都能固定确认一个不可能是 "名人" 的人，因而最多只需要 n-1 次问询，我们就能找到那个最终的 "候选人"
    int queries = 0;
    for(int i = 1; i < n; ++i)
    {
        if(knows(candidate, i))
        {
            candidate = i;
        }
    }
    // 之后我们需要确认这个 candidate 到底是不是真的 "名人"
    for(int i = 0; i < n; ++i)
    {
        // 注意，我们不能检查一个人是否认识自己
        // 否则下面的或条件会为 true，导致丢弃可能正确的结果
        if(candidate == i)
        {
            continue;
        }
        // 一个人是 "名人" 的充分条件是：它不认识任何其他人，而其他所有人都认识他
        if(knows(candidate, i) || !knows(i, candidate))
        {
            return -1;
        }
    }
    // 如果循环检查内部没有确认他不是个 "名人"，我们就可以确认了这个 candidate 是真的 "名人" 了
    return candidate;
}