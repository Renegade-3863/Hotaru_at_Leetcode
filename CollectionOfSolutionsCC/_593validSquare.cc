#include "Solution.h"

bool Leetcode501_600::Soltuion::validSquare(vector<int>& p1, vector<int>& p2, vector<int>& p3, vector<int>& p4)
{
    // 本质上来说，这是一道几何题
    // 我们不妨在纸上画四个点，然后问自己：
    // 怎么判断自己刚刚画的这四个点能不能构成正方形？
    // 我们可以按点来进行考虑
    // 只看两个点能对我们判断这个形状是不是正方形有帮助吗？
    // 似乎不太能，因为两个点必在一条直线上
    // 那么看三个点呢？
    // 似乎有帮助
    // 我们可以先判断这三个点构成的形状是否是一个等腰直角三角形 (注意：一个正方形中，任意取出三个点，都一定会形成一个等腰直角三角形)
    // 如果能构成一个等腰直角三角形，那么我们就只需要判断剩下的那个点是否与这个等腰直角三角形直角点关于斜边对称了
    // 当然，说是对称，其实可以不用搞太复杂的数学计算
    // 我们只需要检查剩下的这个点和是否能和刚刚确认的等腰直角三角形的两个锐角顶点形成另一个直角三角形
    // 按上面的思路来写代码即可
    // len 记录取出的正方形边长 candidate，-1 代表还没取出任何边作为边长
    int len = -1;
    // 计算三个点两两之间的距离
    function<bool(vector<int>&, vector<int>&, vector<int>&) calc = [&](vector<int>& p1, vector<int>& p2, vector<int>& p3) -> bool
    {
    // 计算 p1 和 p2 之间的距离
    int l1 = (p1[1]-p2[1])*(p1[1]-p2[1])+(p1[0]-p2[0])*(p1[0]-p2[0]);
    // 计算 p1 和 p3 之间的距离
    int l2 = (p1[1]-p3[1])*(p1[1]-p3[1])+(p1[0]-p3[0])*(p1[0]-p3[0]);
    // 计算 p2 和 p3 之间的距离
    int l3 = (p2[1]-p3[1])*(p2[1]-p3[1])+(p2[0]-p3[0])*(p2[0]-p3[0]);
    bool ok = (l1 == l2 && l1+l2 == l3) || (l1 == l3 && l1+l3 == l2) || (l2 == l3 && l2+l3 == l1);
    if(!ok)
    {
        return false;
    }
    // 如果这三个点能构成一个等腰直角三角形，那么我们就可以进一步取出这个三角形中的腰边
    if(len == -1)
    {
        // 如果还没取过正方形的边长，那么我们只需要取三条长度中的前两个，就一定能取出对应的边长被选值
        len = min(l1, l2);
    }
    else
    {
        // 已有边长备选值，那么我们需要检查当前这个三角形的腰和备选值是否相等
        if(len == 0 || min(l1, l2) != len)
        {
            // 共线，或者腰不等于备选边长，那么返回 false 即可
            return false;
        }
        // 通过了筛选条件，我们可以结束检查
    }
    return true;
    };
    return calc(p1, p2, p3) && calc(p1, p2, p4) && calc(p1, p3, p4) && calc(p2, p3, p4);
}