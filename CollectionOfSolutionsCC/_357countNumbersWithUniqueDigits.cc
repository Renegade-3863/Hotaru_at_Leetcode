#include "Solution.h"

// 第一版：暴力 DFS，不带记忆化
int Leetcode301_400::Solution::countNumbersWithUniqueDigits(int n)
{
    // 第一次读题被误导了。。以为是只要存在至少两个位上的数字不同即可
    // 实际上这题要求的是所有数位上的数字都不相同
    // 想到题目要我们求出一组数位个数在 [1, n-1] 之间的可行数字个数
    // 我们考虑能不能使用 DP 算法
    // 首先考虑从自顶向下的 DFS 角度思考
    // dfs(i) 代表数位个数最多 i 个的情况下可以得到的数字个数
    // 那么，dfs(i-1) 首先就为我们提供了一组样板
    // 我们可以在 (dfs(i-1)-dfs(i-2)) 的这些数字上进行数字添加
    // 有下面的这个隐含条件：
    // 长度为 i 的数字，它一定使用了 i 个不同的数字，这些数字后面构造的时候就都不能用了
    // 所以对于 dfs(i-1) 的每个数字，我们都只能尾添 10-(i-1) 种数
    // 所以：dfs(i) = (dfs(i-1)-dfs(i-2))*(10-(i-1))
    // 但是，注意到下面的细节问题
    // 如果 i-1 == 1，那么我们很明显不能给 0 做尾添，因为那样构成的数字有前导零
    // 所以我们可以进行一些特殊处理，单独把 dfs(2) 拿出来处理
    function<int(int)> dfs = [&](int i) -> int 
    {
        if(i == 0)
        {
            return 1;
        }
        if(i == 1)
        {
            return 10;
        }
        // 剩下的情况下，我们要考虑 i 是否是 2
        if(i == 2)
        {
            return dfs(1)+9*(10-1);
        }
        // 否则，其它情况下，我们正常递推即可
        return dfs(i-1)+(dfs(i-1)-dfs(i-2))*(10-(i-1));
    };
    return dfs(n);
}

// 解释一下，有人可能会认为，我们递推的时候不能只考虑尾接，还需要考虑把新数插入到前面
// 比如：
// 12 -> 132，中间插入一个3
// 但是这种情况一定会引发重复
// 因为我们还有：
// 13 -> 132，尾接一个2
// 稍微仔细思考一下，就会发现只有尾接数字，我们才不会引入重复
// 如果觉得这样不好理解，我们画个回溯树就明白了

// 第二版：DFS + 记忆化
int countNumbersWithUniqueDigits(int n)
{
    // 记忆化数组
    vector<int> memo(n+1, -1);
    // 第一次读题被误导了。。以为是只要存在至少两个位上的数字不同即可
    // 实际上这题要求的是所有数位上的数字都不相同
    // 想到题目要我们求出一组数位个数在 [1, n-1] 之间的可行数字个数
    // 我们考虑能不能使用 DP 算法
    // 首先考虑从自顶向下的 DFS 角度思考
    // dfs(i) 代表数位个数最多 i 个的情况下可以得到的数字个数
    // 那么，dfs(i-1) 首先就为我们提供了一组样板
    // 我们可以在 (dfs(i-1)-dfs(i-2)) 的这些数字上进行数字添加
    // 有下面的这个隐含条件：
    // 长度为 i 的数字，它一定使用了 i 个不同的数字，这些数字后面构造的时候就都不能用了
    // 所以对于 dfs(i-1) 的每个数字，我们都只能尾添 10-(i-1) 种数
    // 所以：dfs(i) = (dfs(i-1)-dfs(i-2))*(10-(i-1))
    // 但是，注意到下面的细节问题
    // 如果 i-1 == 1，那么我们很明显不能给 0 做尾添，因为那样构成的数字有前导零
    // 所以我们可以进行一些特殊处理，单独把 dfs(2) 拿出来处理
    function<int(int)> dfs = [&](int i) -> int 
    {
        if(memo[i] != -1)
        {
            return memo[i];
        }
        if(i == 0)
        {
            memo[0] = 1;
            return 1;
        }
        if(i == 1)
        {
            memo[1] = 10;
            return 10;
        }
        // 剩下的情况下，我们要考虑 i 是否是 2
        if(i == 2)
        {
            memo[2] = dfs(1)+9*(10-1);
            return memo[2];
        }
        // 否则，其它情况下，我们正常递推即可
        memo[i] = dfs(i-1)+(dfs(i-1)-dfs(i-2))*(10-(i-1));
        return memo[i];
    };
    return dfs(n);
}

// 第三版：转换成自底向上的 DP 算法
int countNumbersWithUniqueDigits(int n)
{
    if(n == 0)
    {
        return 1;
    }
    if(n == 1)
    {
        return 10;
    }
    if(n == 2)
    {
        return 91;
    }
    // n > 2
    vector<int> dp(n+1, 0);
    dp[0] = 1;
    dp[1] = 10;
    dp[2] = 91;
    // 边界情况设定完成，剩下的就是递推了
    for(int i = 3; i <= n; ++i)
    {
        dp[i] = dp[i-1]+(dp[i-1]-dp[i-2])*(10-(i-1));
    }
    return dp[n];
}

// 第四版：空间优化
int countNumbersWithUniqueDigits(int n)
{
    if(n == 0)
    {
        return 1;
    }
    if(n == 1)
    {
        return 10;
    }
    if(n == 2)
    {
        return 91;
    }
    // 用三个变量进行递推
    int dp0 = 10, dp1 = 91, dp2 = 0;
    for(int i = 3; i <= n; ++i)
    {
        dp2 = dp1+(dp1-dp0)*(10-(i-1));
        // 维护定义
        dp0 = dp1;
        dp1 = dp2;
    }
    return dp2;
}