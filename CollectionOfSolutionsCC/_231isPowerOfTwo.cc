#include "Solution.h"

bool Leetcode201_300::Solution::isPowerOfTwo(int n)
{
    // 看起来非常简单的一道题，虽然实际上更简单
    // 我们提出下面的暴论：任何 2 的幂数，它的二进制表示形式中都只能仅有一个1
    // 原因如下：
    // 假设存在一种表示形式：[x1, x2, x3, x4, ..., x32] (32 位二进制数表示的整形数)，这个数是 2 的幂
    // 那么显然有：x1*2^0+x2*2^1+x3*2^2+x4*2^3+...+x32*2^31 = 2^k (k 是一个整数)
    // 而假设上面这一串一维向量中，最大的为1的那个位是 xi 位
    // 那么不难看出 k 必然是不小于 i-1 的
    // 同时：2^0+2^1+...+2^(i-1) 才等于 2^i-1，而 2^k 可取的值只有 {2^(i-1), 2^i, 2^(i+1), ...}
    // 说到这了，大家应该不难发现了
    // 要想前面这一串东西等于一个 2 的幂，只能是考虑 2^(i-1) 这个值
    // 而左边已经有一个 2^(i-1) 了，同时我们又假设过，i 位是一个最靠右的1位，那么左边这一串只能全是0
    // 至此，暴论得证，我们只需要写代码判断 n 的二进制表示中是否只有一个 1 即可
    // 取出最右边的1，我们可以巧妙利用位运算
    return n > 0 && n & (n-1) == 0;
}