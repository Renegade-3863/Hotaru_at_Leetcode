#include "Solution.h"

void Leetcode1_100::Solution::nextPermutation(vector<int>& nums)
{
    // 本题给定一个数字序列，要求根据这个序列找出下一个字典序更大的数字序列
    // 本质上是一道贪心的题目
    // 我们可以以这样的方式进行推理
    // 我们一定是需要把位于后面的一个较大的数字和前面的某个小于它的数字进行交换，才能拿到一个字典序更大的序列
    // 而现在要做的无非就是确定这个较大的数字和较小的数字
    // 我们可以想到，这个较大的数字一定要尽量小，同时前面的较小的数字一定要尽量大，才能保证换过来的序列是紧邻原序列的下一个字典序列
    // 先找被换到后面的数字
    // 可以想到，我们应该从右往左检查当前序列
    // 如果找到了一个单调非递增的后缀，那么这个后缀里面的所有值都不应该是要被换到后面的值，因为那样的话我们就会把一个较大值换到后面了
    // 这样显然会得到一个字典序更小的序列
    // 不难想到我们应该找的是第一个构成了升序关系的数对 (i, j)，满足 i < j，此时这个 i 就是我们应该换到后面的那个较小值
    // 为什么一定要换第一个构成升序数对的那个较小值？
    // 分类进行一下讨论：
    // 如果我们换过来的值 (假设为x) 是大于等于 i 的，那么此时因为 x 也大于 i
    // 那么显然我们把 x 与 i 交换是更合适的
    // 如果我们换过来的值 (假设为x) 是小于 i 的，那么同理，我们知道被换到后面的那个值 (假设为 y) 也一定是小于 i 的。
    // 原序列是 y, .., i, z, .., x
    // 现序列是 x, .., i, z, .., y
    // 那么我们显然忽略了另一种更小的可能方案：把已经找到的逆序对的较大值 (这里是 z) 和 i 互换，甚至如果 z 右边还有比 i 大的值，因为这个值一定不大于 z
    // 所以我们可以换更右侧的值来得到更靠近原序列的更大序列
    // 检查过了以上两种情况后，我们就已经证明了要换的一定是 i，而不是它左边的值
    // 接下来找那个较大的值
    // 它显然应该在 i 的右侧，同时还必须是一个大于 i 的值
    // 经过上面的分析，我们应该知道要和 i 交换的值就一定是从右向左找第一个大于 i 的值，只有这样，才能保证交换后的序列字典序尽量小
    // 可是只进行交换还不够，这样交换后的结果并不一定是紧邻原序列的下一个序列，因为此时序列的递增已经由 i 这个位置上的数字 "霸占" 了
    // 故后面的序列应该还是可以继续减小的 (这个后缀中还可能有降序的序列成分)
    // 把后面这个序列变成最小的话，显然要做的就是把它变成一个完全非降序的序列
    // 由于我们换过来的是第一个大于 i 的值，不难看出我们把 i 换过去之后，后面的序列仍然还是一个非升序序列，那么很显然只需要把它翻转就是一个完全非递降序的序列了
    // 分析过程比较复杂，不过想明白了，代码逻辑就非常好写了
    int i = nums.size()-2;
    while(i >= 0 && nums[i] >= nums[i+1])
    {
        --i;
    }
    // 循环结束后，i 就是从右到左第一个升序数对中较小值的下标
    // 不存在的话，i 的值是-1
    // 继续从右向左找第一个大于 nums[i] 的值的下标
    // 如果数组完全是非升序的，那么这已经是字典序最大的了，可以直接反转整个序列并返回
    if(i == -1)
    {
        reverse(nums.begin(), nums.end());
        return;
    }
    int j = nums.size()-1;
    while(j > i && nums[j] <= nums[i])
    {
        --j;
    }
    // 循环结束后，j 就是从右到左第一个大于 nums[i] 的值的下标，进行交换即可
    swap(nums[i], nums[j]);
    // 把 i 下标右侧的子序列反转即可
    reverse(nums.begin()+i+1, nums.end());
}