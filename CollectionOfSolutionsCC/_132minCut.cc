#include "solution.h"

// 第一版：暴力 DFS，不出意料的超时
int Leetcode101_200::Solution::minCut(string s)
{
    // 本题要求我们计算出把 s 分割成一些回文子串的最少次数
    // 本题也应该能想到是 DP 算法的题目
    // 不过还是不要上来就想递推方程，我们先考虑如何用递归解决问题
    // 我们可以这样考虑子问题：
    // dfs(i, j) 代表我们把 s[i] 到 s[j] 之间的子串分割成全回文所需的最少分割次数
    // 那么，考虑如何进行子问题到母问题的推导
    // 对于 dfs(i, j)
    // 目前能想出的办法是，多进行一轮遍历，考虑最后一次分割的切点是哪里
    // 即：对于所有 k 属于 i 到 j
    // 分别判断 dfs(i, k) 和 dfs(k+1, j)
    // 我们可以按照区间长度来保证在求解 dfs(i, j) 的时候，所有长度小于它本身长度的区间的答案都被正确求解了
    // 当然，上面这个都是后面转 DP 的时候要考虑的问题了
    // 在 DFS 这里我们不需要考虑这些，暴力就完了
    // 想得差不多了，我们就可以开始深搜了
    function<int(int, int)> dfs = [&](int i, int j) -> int
    {
        // 先定义一个递归的基本情况
        // 如果 i >= j，即区间的长度不大于1，那么我们显然不需要任何的分割就能把这个子串切分成均为回文串
        if(i >= j)
        {
            return 0;
        }
        // 否则，区间长度大于1，我们就需要递归进行判断了
        // 遍历整个区间，枚举最后一切的分割点
        int ret = INT_MAX;
        // 把当前区间按下标 k 切分成全回文的次数
        // 等于当前切的这一刀，和把左边和右边区间均切分成全回文的最少次数之和
        for(int k = i; k < j; ++k)
        {
            // 每次遍历都要更新本区间切分次数最小值
            ret = min(ret, 1 + dfs(i, k) + dfs(k+1, j));
        }
        // 注意，还有一种情况，我们如果只使用上面的循环，那么我们相当于默认了 s 的下标 i 到 j 之间的子串本身不是一个回文串
        // 但是有可能这个子串本身就是一个回文串，因而我们还需要额外检查一下这个子串本身
        // 这可以通过 双指针来实现
        int left = i, right = j;
        while(left < right)
        {
            if(s[left] == s[right])
            {
                ++left; --right;
            }
            else
            {
                break;
            }
        }
        // 这一步用来判断这个大子串本身是不是一个回文串
        // 如果上面的循环是正常退出的，那么说明这个子串本身就是一个回文串，我们可以把 ret 改成0
        // 否则这个子串本身不是回文串，我们就正常返回 ret
        if(left >= right)
        {
            ret = 0;
        }
        // 检查结束后，直接返回 ret 结论即可
        return ret;
    };
    // 明确了上面的思路，其实最后我们要做的事情异常简单，直接调用 dfs 函数即可
    return dfs(0, s.size()-1);
}

// 第二版：DFS + 记忆化，依旧超时
int minCut(string s)
{
    // 本题要求我们计算出把 s 分割成一些回文子串的最少次数
    // 本题也应该能想到是 DP 算法的题目
    // 不过还是不要上来就想递推方程，我们先考虑如何用递归解决问题
    // 我们可以这样考虑子问题：
    // dfs(i, j) 代表我们把 s[i] 到 s[j] 之间的子串分割成全回文所需的最少分割次数
    // 那么，考虑如何进行子问题到母问题的推导
    // 对于 dfs(i, j)
    // 目前能想出的办法是，多进行一轮遍历，考虑最后一次分割的切点是哪里
    // 即：对于所有 k 属于 i 到 j
    // 分别判断 dfs(i, k) 和 dfs(k+1, j)
    // 我们可以按照区间长度来保证在求解 dfs(i, j) 的时候，所有长度小于它本身长度的区间的答案都被正确求解了
    // 当然，上面这个都是后面转 DP 的时候要考虑的问题了
    // 在 DFS 这里我们不需要考虑这些，暴力就完了
    // 想得差不多了，我们就可以开始深搜了
    // 添加一个数组用于记忆化
    vector<vector<int>> memo(s.size(), vector<int>(s.size(), -1));
    function<int(int, int)> dfs = [&](int i, int j) -> int
    {
        // 先定义一个递归的基本情况
        // 如果 i >= j，即区间的长度不大于1，那么我们显然不需要任何的分割就能把这个子串切分成均为回文串
        if(i >= j)
        {
            return 0;
        }
        if(memo[i][j] != -1)
        {
            return memo[i][j];
        }
        // 否则，区间长度大于1，我们就需要递归进行判断了
        // 遍历整个区间，枚举最后一切的分割点
        int ret = INT_MAX;
        // 把当前区间按下标 k 切分成全回文的次数
        // 等于当前切的这一刀，和把左边和右边区间均切分成全回文的最少次数之和
        for(int k = i; k < j; ++k)
        {
            // 每次遍历都要更新本区间切分次数最小值
            ret = min(ret, 1 + dfs(i, k) + dfs(k+1, j));
        }
        // 注意，还有一种情况，我们如果只使用上面的循环，那么我们相当于默认了 s 的下标 i 到 j 之间的子串本身不是一个回文串
        // 但是有可能这个子串本身就是一个回文串，因而我们还需要额外检查一下这个子串本身
        // 这可以通过 双指针来实现
        int left = i, right = j;
        while(left < right)
        {
            if(s[left] == s[right])
            {
                ++left; --right;
            }
            else
            {
                break;
            }
        }
        // 这一步用来判断这个大子串本身是不是一个回文串
        // 如果上面的循环是正常退出的，那么说明这个子串本身就是一个回文串，我们可以把 ret 改成0
        // 否则这个子串本身不是回文串，我们就正常返回 ret
        if(left >= right)
        {
            ret = 0;
        }
        // 记忆
        memo[i][j] = ret;
        // 检查结束后，直接返回 ret 结论即可
        return ret;
    };
    // 明确了上面的思路，其实最后我们要做的事情异常简单，直接调用 dfs 函数即可
    return dfs(0, s.size()-1);
}

// 第三版：转为 DP，如果上面的 DFS + 记忆化会超时，那么如果只是简单地转变为 DP，那么很明显还是会超时
// 记录：比第二版纯 DFS 的方案快了一些，主要是由于第二版代码使用了 nt 的双指针方法来判断大子串是否本身就回文这一问题
int minCut(string s)
{
    int n = s.size();
    vector<vector<int>> dp(n, vector<int>(n, 0));
    // 边界情况已经在初始化的时候处理完毕，可以根据区间长度进行递推了
    for(int len = 2; len <= n; ++len)
    {
        for(int i = 0; i <= n-len; ++i)
        {
            // 取出区间的右边界
            int j = i+len-1;
            dp[i][j] = INT_MAX;
            // 进行最后一个分割点的检查
            for(int k = i; k < j; ++k)
            {
                dp[i][j] = min(dp[i][j], 1+dp[i][k]+dp[k+1][j]);
            }
            // 这里，可以根据回文的递推形式来进行整体是否回文的检查，而不用上面傻瓜式的双指针方案
            if(s[i] == s[j] && dp[i+1][j-1] == 0)
            {
                dp[i][j] = 0;
            }
        }
    }
    // 循环结束后，我们就可以返回最终结果了
    return dp[0][n-1];
}

// 第四版：优化 DP -> 从 O(n^3) 转为 O(n^2) 时间复杂度，最终可通过
int minCut(string s)
{
    // 上面的方案使用了 O(n^3) 复杂度的根本原因在于，我们判断的区间是两端均在移动的
    // 同样注意到这样一个事实：我们的区间结果求解只有一个要求，那就是在求解它的时候
    // 它的所有子问题都已经被完全求解
    // 因此我们完全可以固定其中一个边界，只移动另外的边界
    // 比如我们固定左边界 i，使其始终为 0
    // 那么不难写出下面的递推思路
    // dp[i] 代表子串 s[0..i] 切分成均回文所需的最少切割次数
    // 有 dp[i] = min(dp[i], 1+dp[k]), 如果 s[k+1..i] 是一个回文串)
    // 最后有 dp[i] = isPalindrome(i, j)
    // 之后就可以写出下面的代码了
    // 使用 O(n^2) 的时间复杂度计算出字符串所有子串本身是否是回文字符串
    int n = s.size();
    vector<vector<int>> isPalindrome(n, vector<int>(n, true));
    for(int len = 2; len <= n; ++len)
    {
        for(int i = 0; i <= n-len; ++i)
        {
            int j = i+len-1;
            if(s[i] != s[j] || !isPalindrome[i+1][j-1])
            {
                isPalindrome[i][j] = false;
            }
        }
    }
    // 之后我们就可以用上面的方案来优化我们的区间 DP 为线性 DP 了
    vector<int> dp(n, 0);
    // 边界情况 dp[0] 已经在初始化的时候设置完成
    for(int i = 1; i < n; ++i)
    {
        dp[i] = INT_MAX;
        // 在 [0..i] 之间枚举最后一个分割点 k
        for(int k = 0; k < i; ++k)
        {
            // 只有后面分割出的最后一个字符串本身就是回文串的情况下，我们才取前面的结果来进行递推
            if(isPalindrome[k+1][i])
            {
                dp[i] = min(dp[i], dp[k]+1);
            }
            if(isPalindrome[0][i])
            {
                dp[i] = 0;
            }
        }
    }
    // 递推结束后，就可以返回最终结果了
    return dp[n-1];
}