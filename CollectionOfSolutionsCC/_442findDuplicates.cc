#include "Solution.h"

vector<int> Leetcode401_500::Soltuion::findDuplicates(vector<int>& nums)
{
    // 切入题目的关键应该在 "长度为 n" 和 "所有整数都在范围 [1, n] 内" 这两句话中
    // 我们进行一下思考：
    // 我们可以尝试把元素放回原本的位置上，因为如果没有重复，那么这种操作应该是 O(n) 的，同时不会遇到任何阻碍
    // "阻碍" 就是说：当我尝试把某个元素放回它在 nums 数组中对应的位置上时 (和原位置不同)，对应位置上已经有了这个元素
    // 那么很明显这个元素一定是重复的，这是受题目描述限制的 (最多出现两次)
    // 所以，我们只需要按照这种逻辑不断对每个位置上的元素进行替换，一整轮下来，就知道哪些元素是出现了两次的了
    // 具体细节到实际实现中看
    int n = nums.size();
    vector<int> res;
    for(int i = 0; i < n; ++i)
    {
        // 尝试不断把 nums[i] 处的元素放回原本的位置上
        // 直到 i 这个下标上的元素等于 i+1 为止
        while(nums[i] != -1 && nums[i] != i+1 && nums[i] != nums[nums[i]-1])
        {
            // 把 nums [i] 交换到 nums[nums[i]-1] 位置上
            swap(nums[i], nums[nums[i]-1]);
            // 细节死循环问题：如果 nums[i] == nums[nums[i]-1]，即 nums[i] 出现了两次，那么这里会陷入死循环，所以我们需要跳出机制来避免这种情况
        }
        // 判断一下是哪种原因导致的退出
        // 1. nums[i] == i+1，那么没有什么有用的信息，我们只是把对应位置上的元素复原了而已
        // 2. nums[i] == nums[nums[i]-1]，那么说明 nums[i] 这个元素出现了重复，我们对它进行记录即可
        // 但是这种记录是有问题的：
        // 因为同种元素可能会出现两次，因而可能由于其它元素的来回交换，导致重复的那个元素又被交换到了 i 这个下标上，从而导致重复添加
        // 为了避免这种问题，我们可以在添加过一次后，把对应位置上的元素修改成 -1，代表 "已添加过"，从而避免重复添加
        if(nums[i] != -1 && nums[i] == nums[nums[i]-1] && i != nums[i]-1)
        {
            res.push_back(nums[i]);
            nums[i] = -1;
        }
    }
    // 处理完成，返回结果即可
    return res;
}