#include "Solution.h"

string Leetcode401_500::Solution::removeKdigits(string num, int k)
{
    // 题目要求我们对一个数字字符串进行删减，返回一个长度为 n-k 的最小结果
    // 这样转述一下问题，题目的求解思路瞬间就清晰了
    // 我们要做的无非是下面这件事：
    // 从给定字符串中提取出一个长度为 n-k 的序列，要求这个序列的字典序最小(长度相等时，数字字符串的字典序等于实际的大小关系)
    // 那么这题我们很明显应该使用贪心思想来求解
    // 考虑下面的贪心想法：
    // 要一个数最小，肯定是越大的组分越要往后放
    // 所以一个单调非递减的序列一定是我们能找到的最小结果
    // 如何证明上面的这个论述？
    // 对于原本的 num 字符串，我们考虑
    // 如果我们不抽出它的单调非递减序列，而是保留了一部分中间的逆序数对
    // 那么我们很明显可以通过删掉这些数对中更大的那一个元素，转而在尾部填上一些后面更大的元素，从而使得整个数据的值更小
    // 除非我们后面已经没法填入更大元素了，我们才只能选择保留这个逆序对
    // 这也是题目中第一个样例的情况
    // 1219 显然不是一个完整的非递减序列，但是由于我们前面已经删掉了 3 个元素，这个 "21" 是我们能保证的最靠后的逆序对
    // 所以这道题可以使用类似单调栈道方式来求解
    stack<int> stk;
    // 遍历 num，对单调栈进行处理
    int n = num.size();
    // 记住：我们最多允许删掉 k 个元素，再多的就只能尾接了
    int cnt = k;
    for(int i = 0; i < n; ++i)
    {
        // 尽最大努力维护一个单调非递减序列
        while(!stk.empty() && stk.top() > num[i] && cnt > 0)
        {
            // 如果我们还被允许弹出元素，那么就弹出一个栈顶顶较大元素
            stk.pop();
            --cnt;
        }
        // 否则，要么是栈中元素和当前元素满足一个单调非递减关系，要么是栈已经空了，要么就是我们已经没法继续删元素了
        // 这几种情况下我们都可以直接尾接元素 num[i]
        stk.push(num[i]);
    }
    // 处理完成，我们构造答案串即可
    string res = "";
    // 同时，如果我们原来的数值就是一个单调非递减的序列
    // 那么我们很明显有可能会删不到 k 个元素，这时候直接截取我们拿到的单调非递减序列的前 n-k 个元素即可
    while(cnt--)
    {
        stk.pop();
    }
    while(!stk.empty())
    {
        res.insert(res.begin(), stk.top());
        stk.pop();
    }
    // 哦对，别忘了去掉前导零
    while(res != "0" && res[0] == '0')
    {
        res.erase(res.begin(), res.begin()+1);
    }
    return res == "" ? "0" : res;
}