#include "Solution.h"

void Leetcode201_300::Solution::gameOfLife(vector<vector<int>>& board)
{
    // 又一道图论的问题
    // 因为题目要求我们使用原地算法来解决
    // 我们可以使用新的状态标记来对某个位置上细胞的状态变化进行标记
    // 最基本的板子肯定是对整个矩阵进行遍历
    // 我们需要在这个基础上考虑当前位置上细胞的状态
    // 1. 当前细胞是活细胞
    // 此时我们只需要考虑题目给出的条件 1、2、3
    // 检查其周围的八个位置
    // 此时注意到一点
    // 因为当前位置左上的这些格子的状态都是被更新过的，但是我们需要用的是更新前的状态
    // 所以我们可以引入下面两个新的状态标记
    // 当前细胞会 "从活到死"，标记为2
    // 当前细胞会 "从死到活"，标记为3
    // 2. 当前细胞是死细胞
    // 类似，只需要根据题目给出的条件 4 进行更新即可
    // 说太多没太大意义，写代码就可以了
    // 周围八个格子的偏移数组
    const int dirs[8][2] = {{-1, -1}, {-1, 0}, {-1, 1}, {0, 1}, {1, 1}, {1, 0}, {1, -1}, {0, -1}};
    int m = board.size(), n = board[0].size();
    for(int i = 0; i < m; ++i)
    {
        for(int j = 0; j < n; ++j)
        {
            // 别急，写循环体内部之前，我们考察一下四个条件
            // 不难发现，我们都需要，且仅需要一个数据：当前细胞周围的活细胞个数
            // 所以我们可以针对这个值进行预处理
            // cnt 记录的是当前细胞周围活细胞的个数
            int cnt = 0;
            for(int k = 0; k < 8; ++k)
            {
                // 取出对应的位置
                int nexti = i+dirs[k][0], nextj = j+dirs[k][1];
                // 首先还是要判断这个下标是否合法
                // 如果合法，我们进一步判断这个细胞在这个时候是否是活着的
                // 具体些："从活到死" 状态或者 "活细胞" 状态
                if(nexti >= 0 && nexti < m && nextj >= 0 && nextj < n && (board[nexti][nextj] == 1 || board[nexti][nextj] == 2))
                {
                    ++cnt;
                }
            }
            // 结束后，我们就知道来周围此刻有几个活细胞
            // 可以根据这个数据以及当前细胞的死活来对其进行状态更新
            // 1. 当前细胞是活细胞
            if(board[i][j] == 1)
            {
                // 条件1 和 条件3
                if(cnt < 2 || cnt > 3)
                {
                    // 状态改为 "从活到死"
                    board[i][j] = 2;
                }
                // 条件2
                // 保持活着，不用做任何操作
            }
            // 2. 当前细胞是死细胞
            else
            {
                // 条件4
                if(cnt == 3)
                {
                    // 状态改为 "从死到活"
                    board[i][j] = 3;
                }
            }
        }
    }
    // 遍历完成一轮后，再进行一轮遍历，"坐实" 这些变化
    for(int i = 0; i < m; ++i)
    {
        for(int j = 0; j < n; ++j)
        {
            if(board[i][j] == 2)
            {
                board[i][j] = 0;
            }
            else if(board[i][j] == 3)
            {
                board[i][j] = 1;
            }
        }
    }
}