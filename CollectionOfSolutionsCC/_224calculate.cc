#include "Solution.h"

int Leetcode201_300::Solution::calculate(string s)
{
    // 一道据说很常见的面试问题，也是一道结合了递归，栈等知识的综合类题目
    // 不要被数据结构书上讲的离谱优先级算法给蒙骗了，本题没有那么困难，我们可以头脑更简单一点考虑这个问题
    // 因为原问题告诉我们表达式可能带有括号，这个括号看起来很难简单结合运算符的优先级来处理，那么我们可以先不考虑它
    // 假设现在要我们计算的算式只包含基础的运算符 (+、-、*、/ 四种)
    // 那么我们显然可以很简单地得出下面的方案：
    // 我们可以利用一个栈来存储所有基本的，由 + 号结合起来的算子集合
    // 当我们遇到了乘/除号的时候，我们先把栈顶的元素拿出来，和当前数值进行一次计算，再把计算得出的结果压回这个栈
    // 最后，再把整个栈中的元素求和即可
    // 我们尝试实现一遍这个过程
    // 设定一个用于存储所有加法算子的栈
    // 取一个标记当前探查的元素数值符号的字符变量
    // 默认初始值为 '+'
    char sign = '+';
    stack<int> adders;
    int n = s.size();
    // 存储每个运算元素值的变量
    int num = 0;
    // 对整个表达式进行遍历
    for(const char& c: s)
    {
        // 当前的字符有两种可能性：
        // 1. 是一个数字
        // 如果是一个数字，那么由于我们是用字符串表示的表达式，那么可能会出现多位数字的情况，我们需要对数字整体进行累计
        if(isdigit(c))
        {
            num = num*10+(c-'0');
        }
        // 2. 是一个空格
        // 此时我们简单跳过它即可
        else if(c == ' ')
        {
            continue;
        }
        // 3. 是一个运算符
        else
        {
            // 这代表着，我们已经成功拿出了一个运算元素值(这个符号前面的那个值)
            // 此时我们可以通过这个数字前面的符号(对应着外面定义的那个 sign 变量)
            // 来决定要如何处理当前这个刚刚拿出来的元素值
            int prev = adders.empty() ? 0 : adders.top();
            switch(sign) {
                case '+':
                // 如果刚刚拿出来的元素值前面是一个加号，那么显然我们不需要做任何处理，直接压栈即可
                adders.push(num);
                break;
                case '-':
                // 如果刚刚拿出来的元素值前面是一个减号，那么显然我们只需要记录一个 num 的相反数到栈中即可
                adders.push(-num);
                break;
                case '*':
                // 如果我们刚刚拿出来的元素值前面是一个乘号，那么显然我们需要优先把前面一个加法算子拿出来，优先进行一次乘法运算，再把新结果放回栈中
                adders.pop();
                adders.push(prev*num);
                break;
                case '/':
                // 最后，除号和乘号是一样的，不再赘述
                adders.pop();
                adders.push(prev/num);
                break;
            }
            // 处理完前面的 num 和 sign 后，别忘了把它们进行重制
            // sign 变成当前我们发现的这个运算符即可
            // 注意，我们这个计算函数内部并没有对运算式的合法性进行检查，可能需要在外面进行判断
            sign = c;
            num = 0;
        }
    }
    // 全部处理完成后，我们就可以对栈内部的元素进行累加(它们都是最基本的加法算子了)，来得到最终的表达式结果
    int res = 0;
    while(!adders.empty())
    {
        res += adders.top();
        adders.pop();
    }
    // 注意，由于表达式一定是以一个加法算子结尾，而在我们上面的逻辑中，是基于运算符进行处理的，所以会漏掉最后一个算子，我们需要把这最后一个算子也加上
    res += num;
    return res;
}

int calculate(string s)
{
    // 明确了上面不带括号的基本计算逻辑，我们再来考虑一下加入括号这一符号之后如何修改基本的逻辑
    // 首先，需要明确一点，括号本身就带有了一种递归的意味，它促使着我们这样思考：一对括号内部，就是一个小的子计算式
    // 所以，我们对上面代码的修改策略其实意外地简单，添加一层递归即可！
    // 我们把上面的代码复制下来，尝试添加递归入口和结束点即可

    // 规定这样的一个子过程，计算的是表达式 s 从 start 开始的(可能由右括号划定的)同级别子表达式的运算结果
    function<int(const string&, int&)> cal = [&](const string& s, int& i) -> int
    {
        // 基本的逻辑和不带括号的方案基本一致
        char sign = '+';
        int num = 0, n = s.size();
        stack<int> adders;
        
        while(i < n)
        {
            char c = s[i];
            // 根据当前这个字符的类型决定下一步操作
            // 1. 是一个正常数字，累加到 num 中
            if(isdigit(c))
            {
                num = num*10+(c-'0');
                // 越过当前位置即可
                ++i;
            }
            // 2. 不是数字，而是一个左括号
            // 此时由于我们假设原表达式是一个正常的运算式，没有被简化，因而这个左括号前面一定有一个符号存在(即使第一个字符就是一个左括号，它的左边也有一个隐性的 '+' 号)
            // 因而 num 一定是 0，我们就可以简单地给 num 进行重新赋值，不需要考虑覆盖问题
            // 这里 num 是肯定为0的，只要你输入的是正常的运算式，不信你可以用 assert 断言检查一下...
            else if(c == '(')
            {
                // 递归计算从下一个位置开始的下一级别的子表达式的结果
                // 这里有一个小的细节问题：C++ 中，可变左值引用类型的函数参数是不能绑定到任何右值上的，因而这里必须使用 ++i 来进行传参
                num = cal(s, ++i);
                // 同时，在这个过程中，我们也需要同步修改我们的遍历下标 i，避免结束递归后回来又一次检查到这个子表达式
            }
            // 3. 不是数字，而是一个运算符，或者我们已经遍历到了整个表达式的结尾处(注意最后这个位置要么是一个右括号，要么是一个数字字符，不可能是一个运算符)
            // 我们需要把判空格的逻辑放到最后，不然这里逻辑上会有漏洞
            // 比如你遇到了一个是空格的非空字符，那么即使你现在的 num 是一个0，你也会把这个0强行添加到栈中，而且结束后你会把 sign 赋成空格，那么后面的计算就会出问题了
            // 在上面这些其它情况下，我们都需要先记录前面的数字结果
            else if(c != ' ')
            {
                int prev = adders.empty() ? 0 : adders.top();
                // 这里条件判断和上面是完全一致的
                switch(sign) {
                    case '+':
                    adders.push(num);
                    break;
                    case '-':
                    adders.push(-num);
                    break;
                    case '*':
                    adders.pop();
                    adders.push(prev * num);
                    break;
                    case '/':
                    adders.pop();
                    adders.push(prev / num);
                    break;
                }
                sign = c;
                num = 0;
                ++i;
                // 我们可以在这里判断 c 是不是一个右括号，如果是，我们就直接退出循环，计算子表达式结果并返回即可
                if(c == ')')
                {
                    break;
                }
            }
            // 4. 是一个空格，此时我们不需要做任何处理，跳过这个空格即可
            else
            {
                ++i;
            }
        }
        // 第一版的写法有点问题，这里需要带上这个 num 前面的运算符
        // 还是别忘了最后一个加法算子，这个算子我们没有记录到栈中(注意：只有当最后一个字符是数字的时候，我们才会漏掉最后一个算子，如果子表达式的结尾是一个右括号，则不会漏掉)
        // 并且在由右括号退出之前，我们一定会把 num 重制回 0，所以这里可以通过 num 的值来判断我们是不是由右括号退出的循环(注意：也可以使用 sign 来判断)
        if(num != 0)
        {
            int prev = adders.empty() ? 0 : adders.top();
            switch(sign) {
                case '+':
                adders.push(num);
                break;
                case '-':
                adders.push(-num);
                break;
                case '*':
                adders.pop();
                adders.push(prev*num);
                break;
                case '/':
                adders.pop();
                adders.push(prev/num);
                break;
            }
        }
        // 这里的计算方案和前面不带括号的方式是一样的
        int res = 0;
        while(!adders.empty())
        {
            res += adders.top();
            adders.pop();
        }
        return res;
    };
    // 只需要对上面这个运算子过程进行调用即可
    int i = 0;
    return cal(s, i);
}

// 最后进行一轮代码重构即可
int calculate(string s)
{
    // 明确了上面不带括号的基本计算逻辑，我们再来考虑一下加入括号这一符号之后如何修改基本的逻辑
    // 首先，需要明确一点，括号本身就带有了一种递归的意味，它促使着我们这样思考：一对括号内部，就是一个小的子计算式
    // 所以，我们对上面代码的修改策略其实意外地简单，添加一层递归即可！
    // 我们把上面的代码复制下来，尝试添加递归入口和结束点即可

    // 规定这样的一个子过程，计算的是表达式 s 从 start 开始的(可能由右括号划定的)同级别子表达式的运算结果
    function<int(const string&, int&)> cal = [&](const string& s, int& i)
    {
        // 基本的逻辑和不带括号的方案基本一致
        char sign = '+';
        int num = 0, n = s.size();
        stack<int> adders;
        // 只做了这一处重构，把重复使用的 switch 语句包装成了一个子过程供大函数调用，简化了冗余部分
        function<void(int&, char&, int&, stack<int>&)> subCal = [&](int& num, char& sign, int& i, stack<int>& adders)
        {
            int prev = adders.empty() ? 0 : adders.top();
            // 这里条件判断和上面是完全一致的
            switch(sign) {
                case '+':
                adders.push(num);
                break;
                case '-':
                adders.push(-num);
                break;
                case '*':
                adders.pop();
                adders.push(prev * num);
                break;
                case '/':
                adders.pop();
                adders.push(prev / num);
                break;
            }
        }; 
        while(i < n)
        {
            char c = s[i];
            // 根据当前这个字符的类型决定下一步操作
            // 1. 是一个正常数字，累加到 num 中
            if(isdigit(c))
            {
                num = num*10+(c-'0');
                // 越过当前位置即可
                ++i;
            }
            // 2. 不是数字，而是一个左括号
            // 此时由于我们假设原表达式是一个正常的运算式，没有被简化，因而这个左括号前面一定有一个符号存在(即使第一个字符就是一个左括号，它的左边也有一个隐性的 '+' 号)
            // 因而 num 一定是 0，我们就可以简单地给 num 进行重新赋值，不需要考虑覆盖问题
            else if(c == '(')
            {
                // 递归计算从下一个位置开始的下一级别的子表达式的结果
                num = cal(s, ++i);
                // 同时，在这个过程中，我们也需要同步修改我们的遍历下标 i，避免结束递归后回来又一次检查到这个子表达式
            }
            // 3. 不是数字，而是一个运算符，或者我们已经遍历到了整个表达式的结尾处(注意最后这个位置要么是一个右括号，要么是一个数字字符，不可能是一个运算符)
            // 我们需要把判空格的逻辑也捏到这里，不然逻辑上会有漏洞
            // 在上面这些其它情况下，我们都需要先记录前面的数字结果
            else if(c != ' ')
            {
                subCal(num, sign, i, adders);
                sign = c;
                num = 0;
                ++i;
                // 我们可以在这里判断 c 是不是一个右括号，如果是，我们就直接退出循环，计算子表达式结果并返回即可
                if(c == ')')
                {
                    break;
                }
            }
            // 4. 是一个空格，此时我们不需要做任何处理，跳过这个空格即可
            else
            {
                ++i;
            }
        }
        // 第一版的写法有点问题，这里需要带上这个 num 前面的运算符
        // 还是别忘了最后一个加法算子，这个算子我们没有记录到栈中(注意：只有当最后一个字符是数字的时候，我们才会漏掉最后一个算子，如果子表达式的结尾是一个右括号，则不会漏掉)
        // 并且在由右括号退出之前，我们一定会把 num 重制回 0，所以这里可以通过 num 的值来判断我们是不是由右括号退出的循环
        if(num != 0)
        {
            subCal(num, sign, i, adders);
        }
        int res = 0;
        // 这里的计算方案和前面不带括号的方式是一样的
        while(!adders.empty())
        {
            res += adders.top();
            adders.pop();
        }
        return res;
    };
    // 只需要对上面这个运算子过程进行调用即可
    int i = 0;
    return cal(s, i);
}