#include "Solution.h"

double Leetcode601_700::Soltuion::findMaxAverage(vector<int>& nums, int k)
{
    // 乍一看没什么特别好的思路，那么我们先从最简单的解决办法入手
    // 模拟题目的要求，我们遍历长度为 [k, n] 之间的所有窗口
    // 对每种窗口，我们都计算它的平均值
    // 最后，所有平均值取最大的那一个输出
    // 复杂度为 O(nk)，感觉很容易超时，无论超限 n 还是超限 k，都会超时。。
    // len 代表窗口长度，res 保存最后的结果，sum 保存当前窗口中的元素和
    int n = nums.size();
    // 不记得 double 的最小值宏是几了。。
    double res = INT_MIN, sum = 0;
    for(int len = k; len <= n; ++len)
    {       
        // 重置 sum 的值
        sum = 0;
        // 对于长度为 len 的窗口，我们首先计算第一个窗口中的元素和，求平均后滚动窗口即可
        for(int i = 0; i < len; ++i)
        {
            sum += nums[i];
        }
        // sum 是 double 类型，可以把 len 自动类型转换成 double 进行计算
        res = max(res, sum/len);
        // 窗口滚动
        for(int i = len; i < n; ++i)
        {
            sum -= nums[i-len];
            sum += nums[i];
            res = max(res, sum/len);
        }
    }   
    // 遍历完成，返回结果即可
    return res;
}

// 倒在了 76/77，需要优化成 nlogn 级别或者 n 级别复杂度
// 脑海里要有一些简单的 pulse
// 比如 log 级别考虑二分查找，n 级别考虑单调栈或前缀和
// 二分查找似乎不那么合适，因为这道题 nums 中的元素并不具备有序性，而且也并不全部都是正数
// 前缀和和单调栈似乎也不太好用。。

// 事后诸葛亮了：
// 评论区有人 (ref: znzz1) 给出了一个很巧妙的优化方案
// 有下面的关键不等式：
// (A+B)/2 <= max(A, B)
// 乍一看和我们这道题没什么关系
// 不过我们可以这样进行替换：
// (sumi+sumj)/2k <= max(sumi/k, sumj/k)
// 我们会发现，任何一个，长度为 k 的区间的平均值与它后面长度也为 k 的区间的平均值，二者的较大值，都比它和它后面 k 个元素的值求和再平均要大
// 所以我们实际上只需要检查所有长度在 [k, 2k-1] 之间的区间即可
// 有人可能会问，那长度为 4k 的区间呢？
// 首先，长度为 2k 的区间就小于长度为 k 的区间较大值，而长度为 4k 的区间也同理会小于长度为 2k 的区间较值
// 所以 4k，5k 等等的区间我们就都不用考虑了
// 所以上面我们在遍历的时候才把 len <= n 改成了 len < 2*k && len <= n

// 至于那个二分炫技的解法。。我是学不会了，就不管了吧 (弱音)