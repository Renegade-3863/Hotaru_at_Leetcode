#include "Solution.h"

int Leetcode601_700::Soltuion::findLongestChain(vector<vector<int>>& pairs)
{
    // 比较明显的贪心类问题
    // 首先，明确一件事：
    // 越是第二个值小的数对，越可以往前放，因为它们肯定更容易在被添加到结果链中后，在后面继续拼接最多的新数值对
    // 所以，我们可以对所有数值对按照第二个值进行升序排列
    // 排序后，我们可以对整个 pairs 数组进行遍历
    // 我们规定一个已知的 "满足条件的数对链"，最开始这个链是空的 (我们一开始不知道可行的结果)
    // 之后对当前在遍历的这个新的数值对尝试进行尾接
    // 因为这个数值对的结束时间一定比前面任何一个都晚，所以我们只需要考虑它的第一个数值是否小于我们刚刚添加过的最后一个数值对的第二个值即可
    // 因为从定义上来说，前面这个已有的链，是考虑排序时在前面的所有元组，我们可以拿到的最长的链，那么我们现在想要扩展它
    // 只能要么保持这个原有的长度，要么添加一个新的，总长度+1
    // 所以我们才只需要检查前一个元组
    // 如果前一个元组，pairs[i-1][1] 是不大于 pairs[i][0] 的，那么此时我们只能二者选一个
    // 而从我们一开始的讨论，我们会发现，保留原有的这个 pairs[i-1]，我们可以使链条的结束元素更小，这样更可能有更优的结果
    // 所以此时我们选择不要 pairs[i]
    // 而如果前一个元组，pairs[i-1][1] 是小于 pairs[i][0] 的，那么此时我们完全可以把 pairs[i] 接到已知的，前 i-1 个元组序列能拿到的最优解后面
    // 构成一个长度 +1 的链
    // 基于上面的步步为营，每遍历一个新元组 pairs[i]，我们就构建出用 pairs 前 i 个元组能够取出的最优解长度
    // 最后就得到了用 pairs 所有元组，能够搭建出的最长元组序列的长度
    if(pairs.size() < 1)
    {
        return 0;
    }
    sort(pairs.begin(), pairs.end(), [&](const vector<int>& a, const vector<int>& b)
    {
        return a[1] < b[1];
    });
    // 排序完成，我们按上面的逻辑进行遍历即可
    // 我们最少可以有一个结果，就是第一个元组，这里规定初始的右边界为 pairs[0][1]
    int n = pairs.size(), rightMost = pairs[0][1], res = 1;
    for(int i = 1; i < n; ++i)
    {
        // 对于区间 i，考察已知的最优解的右边界值
        if(pairs[i][0] > rightMost)
        {
            rightMost = pairs[i][1];
            ++res;
        }
    }
    return res;
}