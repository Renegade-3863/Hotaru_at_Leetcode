#include "Solution.h"

bool Leetcode401_500::Soltuion::repeatedSubstringPattern(string s)
{
    // 借本题复习一下字符串的 KMP 算法，那个号称学了 N 次还是不能一遍写对的高端子串检索算法
    // 我们先来思考一下为什么本题要用 KMP 算法
    // 本题要求我们找出 s 的一个子串，它必须满足：
    // s's's's'...s' = s
    // 那么如果我们把开头的一个 s' 长度的子串剔除，并补充到剔除后字符串的结尾，我们仍然能拿到同样的字符串 s
    // 而由于 s' 的长度至少为 1，所以我们实际上可以这样做：
    // 把两个 s 字符串拼接起来，这样，如果 s 本身是一个满足 s's's's'...s' 格式的字符串，那么我们一定可以在中间找出一个 s 子部分
    // "中间" 的意思是：不会是拼接的两个 s 中的任何一个
    // 为了避免我们找出开头结尾的两个 s 字符串，我们可以通过删除开头和结尾各一个字符串来 "破坏" 开头结尾的两个 s 字符串
    // 如果这样做了之后，我们依然能够找到一个完整的 s 子串，那么似乎就可以说明这个字符串具备至少一个 "重叠的子部分" 了
    // 不过还不够，我们只能知道如果这个字符串是符合题意的，那么上面的逻辑能够找到 s 子串
    // 但是这不代表如果我们能找到 s 子串，就能断定这个 s 子串是符合题意的
    // 具体的数学证明过程可以参考官方的题解，这里不在数学上赘述了: https://leetcode.cn/problems/repeated-substring-pattern/solutions/386481/zhong-fu-de-zi-zi-fu-chuan-by-leetcode-solution/
    // 看到上面的 "找出子串"，我们就明白为什么要用 KMP 算法了
    // 剩下的就是自己写一下 KMP 算法的整体代码了
    // 首先：KMP 使用一个 "前缀数组" 作为基本的功能模块
    // 这个 "前缀数组" 假设为 next，每个下标用 i 表示
    // 那么 next[j] 的含义有两种：
    // 1. 假设我用匹配串 t[j] 和 s[i] 不能匹配，那么我们下一步应该回卷 j 到 next[j] 下标处继续进行匹配
    // 2. 本质上说，是匹配串 t 中长度为 j 的前缀串中，最长的可以和后缀匹配的前缀的长度
    // 我们要做的就是预处理出这个数组，之后再进行实际的线性遍历流程
    // t 是匹配串本身，虽然本题对应的是 s，但是我们换个名字，来进行区分
    // next 是我们要处理的前缀数组，这个数组在传入之前需要 resize 成和 t 同样长度 (如果是多次定位的 KMP 算法，那么需要多一位长度，本题不需要，同样长度即可)
    function<void(vector<int>&, const string&)> findNext = [&](vector<int>& next, const string& t)
    {
        // 注意，我们这里假设 next.size() == t.size() !!!
        int k = -1, j = 0;
        int n = t.size();
        // next[0] 代表长度为 0 的前缀串的匹配情况，这里我们初始化为 -1
        next[0] = -1;
        // 用一个循环，以类似动态规划的方式对 next 对每一个下标进行填充
        while(j < n)
        {
            // 对 next 的新下标进行填充的情况有两种：
            // 1. k == -1，那么说明 j+1 这个下标前的前缀串本身是没有可匹配的前缀的
            // 2. next[k] == next[j]，那么说明 j+1 这个下标前的前缀串有可以匹配的后缀，这个后缀长度就等于 k+1
            // 综上两种情况，k 和 j 都需要同时递增1，之后再进行赋值
            if(k == -1 || t[k] == t[j])
            {
                ++j; ++k;
                if(j < n)
                {
                    // 这里有一个 KMP 的算法优化，我们举个例子：
                    // 观察这个 t 字符串：
                    // aaaab 
                    // 如果我们想计算它的前缀数组
                    // 必然会计算到倒数第二个 'a'
                    // 这时我们就会定位到前两个 'a' 和后两个 'a' 组成的匹配前后缀
                    // 那么原来的逻辑，next[3] 就会是2，也就是说，我们会尝试用下标为 2 的那个 'a' 再次尝试匹配 s[i] 处的字符
                    // 但是，很明显 next[2] == next[3]，换句话说，我们的匹配是冗余的
                    // 所以如果此时还有 t[j] == t[k]，那么我们可以直接把 next[j] 赋值成 next[k]
                    if(t[j] == t[k])
                    {
                        next[j] = next[k];
                    }
                    else
                    {
                        next[j] = k;
                    }
                }
            }
            // k != -1 && next[k] != next[j]
            // 此时，说明 j 下标处的这个字符不能和当前 k 处的字符匹配，我们需要回退 k，进一步尝试对 j 处字符进行匹配
            else
            {
                k = next[k];
            }
        }
        // 整个循环结束后，next 数组的计算就完成了
    };
    // 剩下的就是利用 next 数组进行实际的 KMP 遍历了
    // 我们利用 next 数组，在 s 字符串中寻找 t 子串是否存在
    function<int(const vector<int>&, const string&, const string&)> KMP = [&](const vector<int>& next, const string& s, const string& t) -> int 
    {
        int i = 0, j = 0;
        int m = s.size(), n = t.size();
        // 结束条件为：i 已经遍历到了结尾，此时无论如何也不可能找到子串了
        while(i < m)
        {
            // 两种状态转移条件
            // 1. j == -1：说明 t 已经完全无法和 s[i] 进行匹配了，那么我们后挪 j 和 i，重新进行 s[i+1] 和 t[0] 的匹配
            // 2. s[i] == t[j]：说明 s[i] 和 t[j] 可以匹配，那么我们正常后挪即可
            if(j == -1 || s[i] == t[j])
            {
                ++i; ++j;
                // j == n 代表着我们已经完成了子串的匹配，可以返回结果了
                if(j == n)
                {
                    // i-n 就是匹配子串的起始下标
                    return i-n;
                }
            }
            // j != -1 && s[i] != t[j]
            // 此时说明 s[i] 不能和 t[j] 匹配，我们需要利用 next 数组的定义回卷下标 j
            else
            {
                j = next[j];
            }
        }
        // 整个循环结束，没有返回 i-n，那么我们直接返回 -1，代表 s 中不存在 t 子串
        return -1;
    };
    // 整个逻辑写好了，剩下的就是调用上面的方法了
    // 首先拼接两个 s 字符串，注意刨除开头结尾两个字符
    string ds = s.substr(1)+s.substr(0,s.size()-1);
    // 利用 KMP 方案定位即可
    // 先初始化 next 数组，大小和 s 相同
    vector<int> next(s.size());
    // 计算 next 数组
    findNext(next, s);
    // 使用 KMP 算法
    return KMP(next, ds, s) != -1;
}