#include "Solution.h"

vector<int> Leetcode301_400::Solution::findMinHeightTrees(int n, vector<vector<int>>& edges)
{
    // 本题只需要明白一个道理：
    // 形成的树高度最小的那一个根结点，一定也是到周围的所有其它结点中最长距离最小的那一个结点
    // 基于这个道理，我们进一步推理：
    // 当当前检查子树中剩余的结点个数多于两个的时候，所有只和一个其它结点相连的结点都一定不会是我们想要的根结点
    // 这个结论其实只要稍微画一画图就能看出来
    // 而如果某一张图中不存在只和一个其它结点相连的结点，那么这张图甚至不可能是一棵树 (因为树是没有环的)
    // 最后，当这张图中只有一个结点的时候，这个结点本身就是答案
    // 当这张图中只有两个结点的时候，很明显两个结点都可以是答案
    // 因而，我们可以采用下面的方法来求解本问题：
    // 1. n == 1，直接返回 0 这个根
    // 2. n == 2，返回包含两个结点的集合作为答案
    // 3. n >= 2，此时我们可以通过不断地从这张图中 "剥离" 只与一个其它结点相连的结点，直到图中只剩一个结点/两个结点，剩下的这些结点就是答案
    // 对于情况3的正确性验证
    // 我们反向来考虑
    // 首先，我们能不断循环 "剥离" 直到图中只剩下不多于两个结点，说明这张图一定是没有环的
    // 其次，由于我们删去的全是不可能成为答案的结果
    // 那么，由于树的定义是没有环的连通图，不考虑连通性的话，这些树一定会存在最小的根
    // 那么我们找到的剩下的这些结点就一定是答案了，因为其它的都不可能
    // 而上面这个 "剥离" 结点的过程，不就是一个完完全全的 BFS 拓扑排序过程吗？
    // 这下好了，连实现方法都不用想了，无脑拓扑即可
    // 先处理情况1和2
    if(n == 1)
    {
        return {0};
    }
    // 不过我们还是需要先处理一下这张图，使用邻接表的方式进行转储
    vector<vector<int>> adjList(n, vector<int>());
    // 我们还需要一个相连结点个数表，记录每个结点和几个其它结点相连
    vector<int> degrees(n, 0);
    for(const auto& edge : edges)
    {
        adjList[edge[0]].push_back(edge[1]);
        adjList[edge[1]].push_back(edge[0]);
        ++degrees[edge[0]];
        ++degrees[edge[1]];
    }
    // 初始化一个队列，用于执行拓扑排序
    queue<int> q;
    for(int i = 0; i < n; ++i)
    {
        // 把所有只和一个其它结点相连的结点添加到队列中
        if(degrees[i] == 1)
        {
            q.push(i);
        }
        // 额外检查，本题虽然用不到，但还是加一下
        if(degrees[i] == 0)
        {
            // 如果某个结点不和任何其它结点相连，那么说明这张图根本不是一个连通图，不用进行后续检查了
            return {};
        }
    }
    // 因为上面我们已经检查过这个图是否是连通的了，所以此时如果这张图中只有两个结点，那么直接返回结果即可
    if(n == 2)
    {
        return {0, 1};
    }
    int remain = n;
    // 进行 BFS 式的拓扑遍历，结束条件如下：
    // 如果遇到了一个结点，它修改后不和任何其它结点相邻了，那么它就是那个唯一的最终答案
    // 否则，如果某轮检查后，图中只剩下了两个结点，那么它们两个就都是答案
    vector<int> res;
    while(remain > 2)
    {
        int cnt = q.size();
        remain -= cnt;
        for(int i = 0; i < cnt; ++i)
        {
            int cur = q.front();
            q.pop();
            // 给和这个结点相邻的那些结点的连接结点数减1
            for(const auto& adj: adjList[cur])
            {
                if(--degrees[adj] == 0)
                {
                    return {adj};
                }
                if(degrees[adj] == 1)
                {
                    q.push(adj);
                }
            }
            // 把和当前结点相连的结点个数置为0，防止后续重复对其修改出现错误
            degrees[cur] = 0;
        }
    }
    while(!q.empty())
    {
        res.push_back(q.front());
        q.pop();
    }
    return res;
}