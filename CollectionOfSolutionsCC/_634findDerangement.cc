#include "Solution.h"

int Leetcode601_700::Soltuion::findDerangement(int n)
{
    const int MOD = 1e9+7;
    // 一眼动态规划类问题
    // 因为我们很容易分析出可行的子问题递推关系：
    // 定义 dfs(i) 代表：以 [1, i] 中的元素进行错位排列，能拿到的所有排列种数
    // 之后，考虑从 dfs(i-1) 递推过来：
    // 首先，我们知道：dfs(i-1) 中的每一种情况都一定是 [1, i-1] 中所有元素的一种错排
    // 而现在我们把 i 放到其中一个序列的末尾：
    // [some permutation of [1, i-1], i]
    // 此时 i 是在原本位置上的，那么要把这个排列变成一个错位排列，我们只需要把 i 和前面 i-1 个数中的一个交换位置即可
    // 注意到：这样交换过来的排列一定依然是错排
    // 因为 [1, i-1] 中的任意一个元素，放到 i 上都是可行的
    // 所以就不难得到：
    // dfs(i) = dfs(i-1)*(i-1) (乘 i-1 相当于把 i 这个值和前面 i-1 个中的任意一个进行交换)
    // 但是上面的递推关系真的正确吗？
    // 试想 [1, 2, 3, 4] 这个序列
    // 那么答案 (肉眼看) 有：
    // [2, 1, 4, 3], [2, 3, 4, 1], [2, 4, 1, 3], [3, 1, 4, 2], ...
    // 我们会发现，比如 [2, 1, 4, 3] 这个序列
    // 按我们上面的递推关系，最后考虑 4 的话，前面这个 3 应该是从 3 号位被交换过来的
    // 但这就和假设相悖了
    // 原来前三个的序列是 [2, 1, 3] ！
    // 完了，递推式不完备
    // 考虑我们漏了哪种 (或者哪些种) 情况？
    // 其实也不难看出来：
    // 我们其实没考虑下面的情况：
    // 使用前 i-1 个数据，但允许其中一个在原位
    // 而这种情况下，我们就必须把 i 和这个在原位的数据进行交换
    // 更换新定义的 dfs 子问题：
    // dfs(i) 代表把 i 个数 (而不是简单定义为 "[1, i] 中的数") 进行错位排列，所有可能的种类数
    // 那么我们可以这样修改递推式：
    // dfs(i) = dfs(i-2)*(i-1)+dfs(i-1)*(i-1)
    // 其中前面这个 dfs(i-2)*(i-1) 的意思是：
    // 我们枚举前面这个 i-1 个数中的任意一个，假定它在原位上，之后让 i 和这个数进行交换，剩下的 i-2 个数进行错位排列
    // 这样就是 dfs(i-2)*(i-1) 种可能了
    // 递推关系处理完毕，剩下的就是写代码了
    function<int(int)> dfs = [&](int i) -> int
    {
        // 注意，由于递推关系中有 i-2 这个参数，所以我们也要处理 i == 2 的基本情况
        if(i == 1 || i == 2)
        {
            // 不难理解。。
            return i-1;
        }
        // 这里实在没办法了，用 i-1L 借助 long 类型避免乘法溢出。。官解也是这么做的
        return (dfs(i-1)+dfs(i-2))%MOD*(i-1L)%MOD;
    };
    return dfs(n);
}

// 优化，做了下记忆化，DP 实在懒得写了，也很简单，就不写了
int findDerangement(int n)
{
    const int MOD = 1e9+7;
    // 加一个记忆化数组
    vector<int> memo(n+1, -1);
    function<int(int)> dfs = [&](int i) -> int
    {
        // 注意，由于递推关系中有 i-2 这个参数，所以我们也要处理 i == 2 的基本情况
        if(i == 1 || i == 2)
        {
            // 不难理解。。
            return i-1;
        }
        if(memo[i] != -1)
        {
            return memo[i];
        }
        // 这里实在没办法了，用 i-1L 借助 long 类型避免乘法溢出。。官解也是这么做的
        memo[i] = (dfs(i-1)+dfs(i-2))%MOD*(i-1L)%MOD;
        return memo[i];
    };
    return dfs(n);
}

// 但是记忆化居然过不了。。
// 罢了，再改成 DP。。
int findDerangement(int n)
{
    if(n == 1 || n == 2)
    {
        return n-1;
    }
    const int MOD = 1e9+7;
    vector<int> dp(n+1, 0);
    dp[2] = 1;
    for(int i = 3; i <= n; ++i)
    {
        dp[i] = (dp[i-1]+dp[i-2])*(i-1L)%MOD;
    }
    return dp[n];
}