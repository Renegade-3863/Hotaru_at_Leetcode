#include "Solution.h"

int Leetcode301_400::Solution::lastRemaining(int n)
{
    // 又是一道数学题，乍一看有点类似约瑟夫环，不过实际上的解法不完全一样，似乎有拿约瑟夫环类似的映射方法求解的
    // 不过比较难想，有兴趣了看一下。。。
    // 我们可以考虑剩下序列的开头元素是怎么变化的
    // 首先，如果当前有奇数个元素，并且我们现在要从第一个元素开始删，那么删完一轮后，一定会剩下偶数个元素，并且开头元素值向后递增1
    // 如果当前有奇数个元素，并且我们现在要从最后一个元素开始删
    // 那么我们还是会删掉开头的元素，而开头的元素会递增删除的轮次这个值(假设已经删除了k轮，那么开头元素+2^k)
    // 如果当前有偶数个元素，并且我们现在要从第一个元素开始删，不难删完一轮后，开头元素也会递增 2^k
    // 只有当前有偶数个元素，并且我们要从最后一个元素开始删的时候，才能保留开头的元素
    // 根据上面的推理进行循环检查即可
    // row 记录当前的轮次，start 记录当前序列的开头元素，n 本身可以用于动态更新数组中剩下的元素个数
    int row = 1, start = 1;
    // 直到剩余的元素个数为 1，我们就可以退出返回结果了
    while(n > 1)
    {
        // 判断当前是要从头开始删还是从结尾开始删
        if(row % 2)
        {
            // 从头开始删
            // 那么无论 n 是奇数还是偶数，开头元素都会递增 row
            start += (1<<(row-1));
        }
        else
        {
            // 从结尾开始删
            // 那么如果 n 是奇数，开头元素递增 row
            // 否则开头元素不变
            if(n % 2)
            {
                start += (1<<(row-1));
            }
        }
        // 每一轮删除，都会剩下 n/2 个元素
        n >>= 1;
        // 递增轮次值
        ++row;
    }
    // 开头元素就是答案
    return start;
}