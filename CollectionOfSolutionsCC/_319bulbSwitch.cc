#include "Solution.h"

int Leetcode301_400::Solution::bulbSwitch(int n)
{
    // 又一次感受到数学对人脑的锻炼。。。
    // 解答就这一行代码
    return (int)sqrt(n);
}

// 如果想更详细一点，可以自己拿双指针二分模拟一遍 sqrt 函数。。。
int bulbSwitch(int n)
{
    int left = 0, right = n;
    int res = 0;
    while(left <= right)
    {
        int mid = ((right-left)>>1)+left;
        // 注意，我们的 sqrt 函数应该是向下取整的，所以这里我们在小于的情况下更新
        if((long long)mid*mid < n)
        {
            res = mid;
            left = mid+1;
        }
        else if((long long)mid*mid == n)
        {
            return mid;
        }
        else
        {
            right = mid-1;
        }
    }
    // 返回最终结果
    return res;
}

// 具体解释一下为什么要找 n 的完全平方根(向下取整)
// 首先，本题可以简化成：有多少个灯泡结束后被调节了奇数次
// 因为只有被调节了奇数次的灯泡，最后是亮着的
// 其次，注意到下面的结论：如果我们检查第 i 个灯泡，那么它会被调节 "它的因数个数" 次
// 这个条件画一画图，稍微思考一下就不难看出来，不过中文版的翻译本身有些问题，所以理解上会有些困难
// 那么，所有因数个数为奇数个的序号上的灯泡都会最后是亮起的
// 之后，还有下面的论断：所有完全平方数的因数个数都是奇数个
// 这一点不难理解，因为完全平方数都会有一个以平方根为分界点的两段
// 只有分界点这一处会增加一个因子
// 其它部分只要增加，就会增加两个因子，所以最后一定是奇数个因子
// 关键在于，是否只有完全平方数会有奇数个因子？
// 换句话说，如果一个数不是完全平方数，它会不会有奇数个因子？
// 应该可以理解：不会
// 因为唯一可能给一个数的因子计数添加1的情况，只能是两个一样的因子，那么就已经说明这是一个完全平方数了
// 最后一点，如何找出 [1, n] 之间的所有完全平方数的个数？
// 又一个很离谱的结论：
// [1, n] 之间的所有完全平方数的个数是 sqrt(n) 个
// 原因是什么？
// 应该这样说：sqrt(n) 计算的是最大的平方不大于 n 的那个数
// 所以，很明显 [1, sqrt(n)] 之间的这些数平方后就是我们要找的那些在 [1, n] 之间的完全平方数！
// 所以最后才有上面的解法
// 挺离谱的一道数学题，见过了就记一下吧。。。