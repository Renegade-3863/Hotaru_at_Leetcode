#include "Solution.h"

// 暴力 DFS，纯纯 TLE 解法
int Leetcode1_100::Solution::numDecodings(string s)
{
    // 看到这种要求算方法种类数的问题，基本上十有八九都是动态规划
    // 不过我们还是不直接思考动态规划的递推方程，先从 DFS 入手
    // 假设 dfs(i) 代表 s 的长度为 i 的子串可以有的所有解码方案数
    // 那么最后的答案显然就是 dfs(n)，其中 n 为 s 的长度
    // 我们思考如何进行递归步骤
    // 即要求解 dfs(i)，我们需要知道哪些信息
    // 1. 如果当前子串的最后两个字符能够构成一个合法的映射
    // 我们应该有 dfs(i-2) 种可能的情况，因为当前这个两位的后缀形成的映射是唯一的
    // 2. 如果当前子串的最后一个字符串能够构成一个合法的映射
    // 我们应该还有 dfs(i-1) 种可能的情况，因为当前这个一位的后缀形成的映射也是唯一的
    // 其实会发现，这其实就是个套了层皮的斐波那契数组问题
    // 根据上面的思路，我们写一版完全 DFS 的代码
    int n = s.size();
    // 用一个哈希集合存一下合法的映射关系
    unordered_set<string> mappings = 
    {
        {"1"}, {"2"}, {"3"}, {"4"},
        {"5"}, {"6"}, {"7"}, {"8"},
        {"9"}, {"10"}, {"11"}, {"12"},
        {"13"}, {"14"}, {"15"}, {"16"},
        {"17"}, {"18"}, {"19"}, {"20"},
        {"21"}, {"22"}, {"23"}, {"24"},
        {"25"}, {"26"}
    };
    function<int(int)> dfs = [&](int idx) -> int
    {
        // 递归基本情况：只包含一个字符的子串，或者不包含任何字符的子串，应该可以简单计算出解码种类数
        // 不包含任何字符的子串显然是可以构成唯一一种解码方案的 (就是解码为空的字母串)
        if(idx == 0)
        {
            return 1;
        }
        if(idx == 1)
        {
            return s.substr(idx-1, 1) != "0";
        }
        // 进行递归求解
        int ans = 0;
        // 检查当前最后两位是否能够形成一个映射
        if(mappings.find(s.substr(idx-2, 2)) != mappings.end())
        {
            ans += dfs(idx-2);
        }
        // 最后一位不能是单独的 "0"
        if(s.substr(idx-1, 1) != "0")
        {
            ans += dfs(idx-1);
        }
        return ans;
    };
    return dfs(n);
}

// 第二版，优化，带上记忆化，可通过，时间超过 43%
int numDecodingsMemo(string s)
{
    // 看到这种要求算方法种类数的问题，基本上十有八九都是动态规划
    // 不过我们还是不直接思考动态规划的递推方程，先从 DFS 入手
    // 假设 dfs(i) 代表 s 的长度为 i 的子串可以有的所有解码方案数
    // 那么最后的答案显然就是 dfs(n)，其中 n 为 s 的长度
    // 我们思考如何进行递归步骤
    // 即要求解 dfs(i)，我们需要知道哪些信息
    // 1. 如果当前子串的最后两个字符能够构成一个合法的映射
    // 我们应该有 dfs(i-2) 种可能的情况，因为当前这个两位的后缀形成的映射是唯一的
    // 2. 如果当前子串的最后一个字符串能够构成一个合法的映射
    // 我们应该还有 dfs(i-1) 种可能的情况，因为当前这个一位的后缀形成的映射也是唯一的
    // 其实会发现，这其实就是个套了层皮的斐波那契数组问题
    // 根据上面的思路，我们写一版完全 DFS 的代码
    int n = s.size();
    // 用一个哈希集合存一下合法的映射关系
    unordered_set<string> mappings = 
    {
        {"1"}, {"2"}, {"3"}, {"4"},
        {"5"}, {"6"}, {"7"}, {"8"},
        {"9"}, {"10"}, {"11"}, {"12"},
        {"13"}, {"14"}, {"15"}, {"16"},
        {"17"}, {"18"}, {"19"}, {"20"},
        {"21"}, {"22"}, {"23"}, {"24"},
        {"25"}, {"26"}
    };
    // 记忆化表格，用于记录每个长度的前缀子串所能形成的个数
    unordered_map<int, int> memo;
    function<int(int)> dfs = [&](int idx) -> int
    {
        if(memo.find(idx) != memo.end())
        {
            return memo[idx];
        }
        // 递归基本情况：只包含一个字符的子串，或者不包含任何字符的子串，应该可以简单计算出解码种类数
        if(idx == 0)
        {
            return 1;
        }
        if(idx == 1)
        {
            return s.substr(idx-1, 1) != "0";
        }
        // 进行递归求解
        int ans = 0;
        // 检查当前最后两位是否能够形成一个映射
        if(mappings.find(s.substr(idx-2, 2)) != mappings.end())
        {
            ans += dfs(idx-2);
        }
        // 最后一位不能是单独的 "0"
        if(s.substr(idx-1, 1) != "0")
        {
            ans += dfs(idx-1);
        }
        // 先记录后返回结果
        memo[idx] = ans;
        return ans;
    };
    return dfs(n);
}

// 第三版：再转化成 DP，正向递推，按理说会比上面的记忆化少一些递归调用的开销，不过还是只超过了 43%
int numDecodingsDP(string s)
{
    int n = s.size();
    unordered_set<string> mappings = 
    {
        {"1"}, {"2"}, {"3"}, {"4"},
        {"5"}, {"6"}, {"7"}, {"8"},
        {"9"}, {"10"}, {"11"}, {"12"},
        {"13"}, {"14"}, {"15"}, {"16"},
        {"17"}, {"18"}, {"19"}, {"20"},
        {"21"}, {"22"}, {"23"}, {"24"},
        {"25"}, {"26"}
    };
    vector<int> dp(n+1, 0);
    dp[0] = 1; dp[1] = s.substr(0, 1) != "0";
    for(int i = 2; i <= n; ++i)
    {
        if(mappings.find(s.substr(i-2, 2)) != mappings.end())
        {
            dp[i] += dp[i-2];
        }
        if(s.substr(i-1, 1) != "0")
        {
            dp[i] += dp[i-1];
        }
    }
    return dp[n];
}

// 第四版：优化空间，把一维 DP 数组压缩成 O(1) 的单一变量，不知道为啥，优化了空间复杂度，时间反而超过了 100%...
int numDecodingsDPOpt(string s)
{
    int n = s.size();
    unordered_set<string> mappings = 
    {
        {"1"}, {"2"}, {"3"}, {"4"},
        {"5"}, {"6"}, {"7"}, {"8"},
        {"9"}, {"10"}, {"11"}, {"12"},
        {"13"}, {"14"}, {"15"}, {"16"},
        {"17"}, {"18"}, {"19"}, {"20"},
        {"21"}, {"22"}, {"23"}, {"24"},
        {"25"}, {"26"}
    };
    int dp0 = 1, dp1 = s.substr(0, 1) != "0";
    for(int i = 2; i <= n; ++i)
    {
        int tmp = 0;
        if(mappings.find(s.substr(i-2, 2)) != mappings.end())
        {
            tmp += dp0;
        }
        if(s.substr(i-1, 1) != "0")
        {
            tmp += dp1;
        }
        dp0 = dp1;
        dp1 = tmp;
    }
    return dp1;
}