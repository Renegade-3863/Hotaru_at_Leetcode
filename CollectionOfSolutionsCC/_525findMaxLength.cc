#include "Solution.h"

int Leetcode501_600::Soltuion::findMaxLength(vector<int>& nums)
{
    // 从题目描述入手考虑这道题
    // 题目要求找出的是：含有相同数量的 0 和 1 的最长连续子数组
    // 这句话乍一看比较难理解
    // 不过从本质上说，目的就是找出一个下标对 (i, j)
    // 这对下标满足：
    // 1. 区间中 1 和 0 的个数相同
    // 2. 同时 (j-i+1) 这个值在所有满足条件 1 的 (i, j) 对中是最大的
    // 那么我们不难想到，可以用前缀和的方式来求解这道题
    // 我们在前缀和数组中需要存储的数据为：
    // preSum[i] = nums[0..i] 中，1 和 0 的个数差值 (具体的，如果 1 比 0 多，那么值为正数；否则，值为负数)
    // 之后，我们考虑下面的逻辑：
    // 当检查到 preSum[i] 时，我们检查前面已经记录过的所有前缀和值，如果某个前缀和中 1 比 0 多的个数和本次检查出的，当前前缀和中 1 比 0 多的个数是互补的 (和值为 0)
    // 那么我们就找到了一组可行的子数组
    // 遵循上面的逻辑，我们引入一个哈希表来加速查找即可
    // 细节：题目要求我们返回的是对应子数组的长度，所以有必要记录每一种前缀和值出现的 "最早下标"
    // 因为最早下标可以让我们计算出最长的满足条件组数组的长度
    unordered_map<int, int> memo;
    // 注意，我们依然不需要整个前缀数组，哈希表可以承担记录的责任
    int preSum = 0, n = nums.size();
    // 最开始，记录 "最靠左的，0 和 1 数量差值为 0 的前缀串结束下标为 -1"
    // 因为，不含有任何 0 或 1 的子串，就是一个含有相同数量的 0 和 1 的连续子数组
    memo[0] = -1;
    int maxLen = 0;
    for(int i = 0; i < n; ++i)
    {
        // 累计 preSum
        // 累加方法很简单，如果 nums[i] 是 1，就加 1，如果是 0，就减 1
        preSum += nums[i] == 1 ? 1 : -1;
        // 之后是检查 memo 中是否保存了 preSum 和值的下标，如果有，那么更新最长的子数组长度
        if(memo.count(preSum))
        {
            // 注意：preSum 记录的是前缀，我们要计算的，是前缀下标 j 之后，到 i 之间的元素长度
            // 也就是 (j, i] 这个区间，所以应该是 i-j，而不是 i-j+1
            maxLen = max(maxLen, i-memo[preSum]);
        }
        // 把 preSum 记录到 memo 中，注意，只有没记录过的时候，我们才进行记录
        if(!memo.count(preSum))
        {
            memo[preSum] = i;
        }
    }
    // 返回结果即可
    return maxLen;
}