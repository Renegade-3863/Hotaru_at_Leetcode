/*
    线段树板子，这里是基于 "区间和" 这一概念给出的模版
    基于如下假设：
    有一个数组 a，要维护的是 "区间和" 信息
    d 代表线段树数组（一般推荐维护的长度为数组 a 的 4 倍长
*/


// 对编号为 p，代表区间 [s, t] 上的某个信息值的线段树进行建树操作
void build(int s, int t, int p)
{
    if(s == t)
    {
        // 这个节点代表的是一个单个值，这是树的根节点，结束递归建树过程
        d[p] = a[s];
        // 结束点，不再深入递归
        return;
    }
    // 取区间中点
    int m = s + ((t - s) >> 1);
    // 递归对左右子树进行构建
    build(s, m, p*2); build(m+1, t, p*2+1);
    // 递归建树后，更新当前节点维护的值（上溯）
    d[p] = d[p*2]+d[p*2+1];
}

// 线段树的区间查询
// 查找编号为 p，代表区间 [s, t] 的节点中，对应与 [l, r]（要查区间）有交集的部分
int getSum(int l, int r, int s, int t, int p)
{
    if(l <= s && t <= r)
    {
        // 这种情况下，说明要查询的区间包含了当前节点所代表的区间
        // 那么直接返回当前节点保存的值即可
        return d[p];
    }
    // 否则，还剩两种情况
    // 1. [s, t] 与 [l, r] 无交集
    // 2. [s, t] 与 [l, r] 有交集，但 [l, r] 不包含 [s, t]
    int m = s + ((t - s) >> 1), sum = 0;
    // 如有必要，递归检查左右子区间
    if(l <= m)
    {
        sum += getSum(l, r, s, m, p*2);
    }
    if(r > m)
    {
        sum += getSum(l, r, m+1, t, p*2+1);
    }
    return sum;
}

// 线段树的区间修改与懒惰标记
// 修改编号为 p，代表 [s, t] 的区间节点，要实际更新的区间是 [l, r]
// 每个元素的更新值为 c
void update(int l, int r, int c, int s, int t, int p)
{
    // 如果当前节点代表的区间被要实际更新的区间所包含，那么直接打个懒标记
    // 然后更新当前节点保存的结果即可
    if(l <= s && t <= r)
    {
        d[p] += (t - s + 1) * c, b[p] += c;
        return;
    }
    int m = s + ((t - s) >> 1);
    // 如果当前节点有懒信息
    // 由于走到这一步，说明我们要修改的区间 [l, r] 与当前节点代表的区间是有交集的
    // 那么我们需要把懒信息下放给当前节点 p 的两个孩子节点
    // 注意，这里更新的只是以前的老数据，不是本次更新的数据
    if(b[p] && s != t)
    {
        d[p*2] += b[p] * (m - s + 1);
        d[p*2+1] += b[p] * (t - m);
        // 下传懒信息
        b[p*2] += b[p]; b[p*2+1] += b[p];
        // 清空当前节点的懒标记
        b[p] = 0;
    }
    // 这里才是实际更新当前轮次的数据
    // 如果 l <= m，说明左孩子需要进一步更新
    if(l <= m)
    {
        update(l, r, c, s, m, p*2);
    }
    if(r > m)
    {
        update(l, r, c, m+1, t, p*2+1);
    }
    // 重新计算结果
    d[p] = d[p*2] + d[p*2+1];
}

// 带懒信息的区间查询函数
int getSumLazy(int l, int r, int s, int t, int p)
{
    // 如果当前要查询的区间包括了节点 p 代表的区间，直接返回保存的值即可
    if(l <= s && t <= r)
    {
        return d[p];
    }
    // 否则，需要分左右子节点来看
    int m = s + ((t - s) >> 1);
    if(b[p])
    {
        // 如果 p 节点有懒信息，此时就必须下方给左右孩子
        // 先把懒信息更新下去
        d[p*2] += b[p] * (m - s + 1);
        d[p*2+1] += b[p] * (t - m);
        b[p*2] += b[p]; b[p*2+1] += b[p];
        // 清空懒信息
        b[p] = 0;
    }
    // 记录结果
    int sum = 0;
    if(l <= m)
    {
        sum = getSum(l, r, s, m, p*2);
    }
    if(r > m)
    {
        sum += getSum(l, r, m+1, t, p*2+1);
    }
    return sum;
}