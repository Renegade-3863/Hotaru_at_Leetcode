## 218 天际线问题

#### 题目描述如下：
> 城市的 天际线 是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。给你所有建筑物的位置和高度，请返回 由这些建筑物形成的 天际线 。

> 每个建筑物的几何信息由数组 buildings 表示，其中三元组 buildings[i] = [lefti, righti, heighti] 表示：

- lefti 是第 i 座建筑物左边缘的 x 坐标。
- righti 是第 i 座建筑物右边缘的 x 坐标。
- heighti 是第 i 座建筑物的高度。

> 你可以假设所有的建筑都是完美的长方形，在高度为 0 的绝对平坦的表面上。

> 天际线 应该表示为由 “关键点” 组成的列表，格式 [[x1,y1],[x2,y2],...] ，并按 x 坐标 进行 排序 。关键点是水平线段的左端点。列表中最后一个点是最右侧建筑物的终点，y 坐标始终为 0 ，仅用于标记天际线的终点。此外，任何两个相邻建筑物之间的地面都应被视为天际线轮廓的一部分。

> 注意：输出天际线中不得有连续的相同高度的水平线。例如 [...[2 3], [4 5], [7 5], [11 5], [12 7]...] 是不正确的答案；三条高度为 5 的线应该在最终输出中合并为一个：[...[2 3], [4 5], [12 7], ...]


##### 问题解析：
我们可以先从暴力的角度找出本题的一种易懂的解决方案
- 不难发现我们根本上来说，要找的就是每一个横坐标处可得到的最高建筑高度值(注意：一栋建筑的右边界不能记录进来，根据题目定义，这个下标上的高度值不算合法的天际线)
- 每次检查一个区间 [left, right, height]，我们需要做的就是更新 [left, right) 这个区间中的所有下标的高度值 (注意，是一个作闭右开区间，原因就是右边界不能成为合法的天际线)
- 如果我们单纯暴力更新这些下标，显然会出现很多多余的更新，比如要更新 [3, 7) 中的所有下标的最大高度值为 15，那么此时我们实际上没必要整个遍历一轮 [3, 4, 5, 6] 这四个值，而可以用一个区间结点 [3, 6] 来代表这整个区间，用一个 "懒标记" 来代表整个区间性质的修改
- 明确了上面的策略，我们其实就已经学完了 "线段树" 这种高级数据结构的基本思想了，就是高效的区间性质修改和查询。

- 考虑如何实现这样一棵树
    - 简单点想：完全可以通过类似完全二叉树的结构来实现这样的数据结构
    - 具体为：我们通过对一个完整区间进行不断二分，用完全二叉树的各结点分别代表对应的二分区间即可，剩下的修改策略本质上就是递归过程，不需要讲太顶层的逻辑，只需要写代码的同时随写随想即可

- 第一步：建树
- 对于本题，我们会发现这样一个特性：得出的天际线值一定是在各个建筑物的边界值位置上，也就是，不需要记录任何没出现过建筑边界的下标值的信息，我们只需要通过那些有建筑的边界值出现的下标来对线段树进行更新即可

1. 先构建结点结构体
``` C++
// 结点要存储的是，当前区间的左右界，以及它存储的这个区间的属性值(最大值/最小值/区间和)，本题这个属性值就是最大值
// 定义一个树的叶子结点个数，用一个足够涵盖所有情况的值就行
const int N = 20005;
struct Node 
{
    int left;
    int right;
    int height; // 本题需要维护的属性值就是高度的最大值
}tree[4*N];
```
2. 之后是建树函数
``` C++
// 建立一棵表达区间 [l, r] 的线段树
// 注意这个函数是递归定义的
void build(int p, int l, int r)
{
    // 先构建根结点
    // 假设我们用数组的形式来存储线段树(也是二叉树)的各个结点
    // 这个数组的名字是 tree
    tree[p].left = l; tree[p].right = r;
    // 递归构造的结束条件：当前区间只有一个结点
    // 此时已经无需进一步深入了，之间返回即可
    if(tree[p].left == tree[p].right)
    {
        return;
    }
    // 否则，需要进一步深入递归构造左右孩子结点
    int mid = ((r-l)>>1)+l;
    // 2*p 代表左孩子
    build(2*p, l, mid);
    // 2*p+1 代表右孩子
    build(2*p+1, mid+1, r);
}
```
3. 关于树的更新，我们需要了解到，线段树除了加快了区间的查找效率(原本在一维数组上的区间查找不难想到是一个线性的复杂度)，现在变成了二分查找的对数级别复杂度，同时还具备我们前面提到过的 "懒更新" 性质，意思在于：只有当我想要查找当前大区间的一个子区间的时候，我们才把在上层大区间记录的性质值更新 "广播" 给子区间，来优化掉不必要的重复更新(如果不这样做，可以预见这棵树和单纯的一维数组没有任何区别)
    
    > 下面给出 "懒更新" 的代码
``` C++
// 定义为根据当前序号为 p 的结点向其两个孩子 "懒更新" 一次
// 注意，这个函数只有在 "需要被用到" 的时候才会被调用
void lazyUpdate(int p)
{
    // 关于层间的更新，我们只需要从当前结点通知它的两个子结点：上头有检查的了，我把我知道的信息告诉你，你被查的时候告诉上头的人就行
    // 如果当前结点中存在数据(本身也是懒数据)
    // 可以向孩子结点扩散的，那么就进行扩散
    if(tree[p].height != 0)
    {
        tree[2*p].height = max(tree[p].height, tree[2*p].height);
        tree[2*p+1].height = max(tree[p].height, tree[2*p+1].height);
        tree[p].height = 0;
    }
}
```

4. 真正的树更新函数
``` C++
// 要更新的是 [l, r] 上所有的下标，要更新的可能值是 h
// 注意，这个区间是受到结点 p 的限制
void update(int p, int l, int r, int h)
{
    // 情况1. 要更新的区间囊括了当前结点整体，我们便不再需要分裂，进一步更新这个结点的分支结点
    if(tree[p].left >= l && tree[p].right <= r)
    {
        // 那么我们可以把这个更新完全 "委托" 给这个被完全包住的结点，不需要再继续深入修改
        tree[p].height = max(tree[p].height, h);
        return;
    }
    // 否则，我们会需要继续递归地更新当前结点被 [l, r] 覆盖到了的那部分
    // 注意，在更新之前，我们需要先进行一次 "懒更新"，也就是上面说到的，"需要被用到" 的状态
    // 因为这个时候可能会有这样的情况：
    // 我们之前对这个区间进行过 "懒更新"，因而此时它的两个孩子还没有实际获知这个 "懒更新" 的内容，因而我们需要先进行更新后再分别深入修改
    lazyUpdate(p);
    // 此时两个孩子已经知道了之前懒更新的内容，我们可以继续分开深入进行更新了
    // 还是先切分当前结点的区间
    int mid = ((tree[p].right-tree[p].left)>>1)+tree[p].left;
    // 关注两半区间是否都需要进行进一步的修改
    if(l <= mid)
    {
        update(2*p, l, r, h);
    }
    if(r > mid)
    {
        update(2*p+1, l, r, h);
    }
}
```

5. 最后需要的就只剩下查询函数了，就是说，我们维护了这个数据结构，最终的目的就是为了需要的时候从中查询出我们需要的信息。这个查询的函数我们使用类似上面更新的方法进行递归定义
``` C++
int query(int p, int x)
{
    // 类似的递归结束条件，如果当前结点维护的区间长度为1，那么我们就可以直接返回这个单一结点的值(注意，可能需要对结果的合法性进行检查，因为我们可能并没有在当前线段树中存储这个 x 下标，所以额外进行一下检查也是可以的)
    if(tree[p].left == tree[p].right)
    {
        // 这里我们返回一个 -1 值作为 "不合法" 的意义
        return tree[p].left == x ? tree[p].height : -1;
    }
    // 否则，我们尝试对这个区间的两个子区间进行搜索
    // 并且，在深入递归搜索之前，我们依然需要把可能的 "懒更新" 信息先传递给两个孩子
    lazyUpdate(p);
    // 这里和二叉搜索树的二分操作的基本模式是一样的
    int mid = ((tree[p].right-tree[p].left)>>1)+tree[p].left;
    // x 在 mid 的左侧，我们需要递归检查左孩子
    if(mid >= x)
    {
        return query(2*p, x);
    }
    // 否则，x 在 mid 的右侧，我们需要递归检查右孩子
    return query(2*p+1, x);
}
```

##### 搞清了上面这种高效的区间信息存取结构，我们终于可以转回来处理这道题了
- 其实说实话，只需要按这些 "建筑物" 的左右边界作为实际更新线段树的 "区间边界" 即可，我们的线段树之需要存储一个满足题意要求的 "区间边界值" 个数大小的结点即可
- 举个例子：题目中给出的第一个例子：
> buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]
- 对于上面的几个区间，我们实际上之需要根据 (2, 3, 5, 7, 9, 12, 20, 24) 这几个分立的值进行线段树的区间更新即可，不会用到其它的值，因而我们不需要实际存储一个完全包含所有正整数的大区间，可以压缩成一个更小的由映射关系构造出来的更小的区间：
> 2 -> 1, 3 -> 2, 5 -> 3, 5 -> 4, 9 -> 5, 12 -> 6, 20 -> 7, 24 -> 8 这种感觉即可
- 注意到，要完成上面这种映射，我们就必须取出建筑数组的左右边界并进行排序和去重，这就属于编程语言层面的内容了。
- 不再赘述，直接从代码中得出解法即可

``` C++
vector<vector<int>> getSkyline(vector<vector<int>>& buildings) {
    // 使用的数据结构和方法都是上面定义过的
    // 第一步，对 buildings 数组进行处理，拿出所有建筑的左右边界值，之后进行映射计算
    // 存储映射关系的哈希表
    unordered_map<int, int> mapping;
    // 存储所有分立值的数组
    vector<vector<int>> ans;
    for(int i = 0; i < buildings.size(); ++i)
    {
        ans.push_back(buildings[i][0]);
        ans.push_back(buildings[i][1]);
    }
    // 之后处理这个 ans 数组，先进行排序和去重
    sort(ans.begin(), ans.end());
    // 之后是 C++ STL 常用的数组去重策略
    // unique(ans.begin(), ans.end()) 代表的是把一个有序数组中唯一的部分提到数组开头，返回一个指向最后一个不重复的元素之后的第一个元素的迭代器，我们可以利用这个迭代器执行元素的删除
    ans.erase(unique(ans.begin(), ans.end()), ans.end());
    // 现在我们拿到了所有分立元素，下一步就是建立映射了
    for(int i = 0; i < ans.size(); ++i)
    {
        mapping[ans[i]] = i+1;
    }
    // 之后就只需要执行线段树相关的操作了
    // 从序号1开始构建这棵线段树
    int n = ans.size();
    build(1, 1, n);
    // 之后需要根据给定的 buildings 数组对区间进行数值修改
    for(int i = 0; i < buildings.size(); ++i)
    {
        // 注意我们最开始说过的内容，每个建筑的最右侧边界高度不能计入天际线的考虑范围，所以这里我们给右边界进行-1操作，再进行映射
        update(1, mapping[buildings[i][0]], mapping[buildings[i][1]-1], buildings[i][2]);
    }
    // 更新完成后，我们只需要针对每个分立的下标值进行一次查询，检查这个下标处的最高高度值即可
    // 根据对天际线定义的观察，我们不难发现，只要某两个分立值处的最大高度出现了变化，那么久一定会出现对应的结果坐标，我们只需要相应地进行记录即可
    vector<int> res;
    // 记录前一个分立下标处的最大高度值
    // 初始值为 0
    int maxv = 0;
    for(int i = 0; i < buildings.size(); ++i)
    {
        int x = query(1, mapping[ans[i]]);
        if(maxv != x)
        {
            // 记录高度即可
            res.push_back({ans[i], x});
        }
        // 根据 maxv 的定义对其进行更新
        maxv = x;
    }
    // 找完了，返回结果即可
    return res;
}
```