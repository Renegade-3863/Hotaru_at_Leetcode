## 13 最长公共前缀

### 题目描述如下:

> 编写一个函数来查找字符串数组中的最长公共前缀。

> 如果不存在公共前缀，返回空字符串 ""。

#### 这道题最简单的想法就是把整个字符串数组拉成竖直的一列然后逐行判断

具体情况如下:

e.g.

{

"flower",

"flow",

"flight",

}

从左到右一列一列的观察整个数组中的每个字符串,

字符'f'是所有字符串公共的,则字符串"f"确定是该数组目前已知的最长公共前缀

字符'l'是所有字符串公共的,则字符串"fl"确定是该数组目前已知的最长公共前缀

字符'o'不是所有字符串公共的,终止循环,已知的最长公共前缀就是"fl"


我们可以通过一个两层循环实现上述过程,复杂度显然为O(mn)(m为行数,n为列数)

#### 代码如下:

```C++
class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {
        // 这里的len对应文字说明的n,n对应文字说明的m
        int len = strs[0].size(), n = strs.size();
        string res = "";
        for(int i = 0; i < len; ++i) {
            char c = strs[0][i];
            for(int j = 0; j < n; ++j) {
                if(i == strs[j].size() || strs[j][i] != c)
                    return res;
            }
            res += c;
        }
        return res;
    }
};
```
不过一旦涉及到字符串,长度,匹配这几个字眼,相信老力扣人都会不由自主的想到一个词: 二分

#### 那么我们可以尝试一下二分思想

经常刷算法题的小伙伴们应该猜到了大概的方法:

取第一个字符串的长度作为最长前缀长度的最大可能值(因为不可能有前缀的长度比第一个字符串的长度还长)

之后,以最短前缀长度0(假设为l)和这一最大值(假设为r)作为二分区间的左右端点,我们可以对问题结果的取值区间[l, r]不断进行二分

如果长度为[l, r]中间值mid那么长的前缀都不是合法的,那么我们就可以的丢弃所有长度不小于mid的前缀长度可能值: r = mid-1;

否则,我们就可以丢弃所有长度小于mid端点前缀长度可能值: l = mid

最后,当区间里只有l一个值(l == r)的时候,l就是那个结果

#### 那么这里就会涉及到一个实现细节的问题:

区间[l, r]的中间值mid怎么取?(实际上,这是一个二分方法能否AC的最关键一步!!!)

有人可能会觉得是 mid = ((r-l)>>1)+l, 即数学上的(l+r)/2 

看起来没什么问题,可是,如果有这样一个例子:

{

"a",

"a"

}

我们的取法会怎么做?

我们取最短前缀长度为0,最长为"a"的长度1

之后计算mid: mid == ((r-l)>>1)+l == 0

欸,我们应该取strs[0]的长度为0的前缀进行判断!!

#### 等等!!!是不是搞错了什么?

如果这样的话,取到的前缀是什么? 空字符串""!

这样我们会很自然的判断出这个前缀无法和第二个字符串"a"的任何前缀匹配,

于是将r变为mid-1,也就是-1 => 所以最大前缀长度是-1????

显然不对吧,这两个字符串的公共前缀很明显是"a"本身吧

回看这个取中间值的式子:

    mid = ((r-l)>>1)+l

我们不难知道,它求解的是一个开区间中中间靠左的那一个中间值(如果区间中有偶数个值)

因为这个式子等价于(l+r)>>1,而后者对奇数应用了截断小数位的策略

而上面的错误示例,我们求取的是[0, 1]这个区间的中间值,此时区间中有两个值(偶数),那么mid会取0, 这时候新长度mid就显然不再是一个合法值了

所以为了避免取左端点可能会取到0这种尴尬的错误,我们应该修改上面的式子,让它在区间中有偶数个值的时候取中间靠右的那一个中间值!

怎么修改呢?

Claim:

    mid = ((r-l+1)>>1)+l  这个式子求的就是靠右的那一个

为什么呢?

我们已经知道原mid公式在区间中有偶数个值的时候((r-l)为奇数)的时候,取的是中间靠左的那一个值作为中间值,那我们给(r-l)这个东西加上1,把它变成右侧的偶数, 是不是就是取了靠右的那一个中间值呢?

#### 答案是肯定的

从数学角度思考:

(l+r)/2在计算机中是自动向下取整的

也就是说(l+r+1)/2应该等于(l+r)/2(左值)或(l+r+2)/2, 即(l+r)/2+1(右值)

同理: 

(r-l+1)/2+l应该等于(r-l)/2+l或(r-l+2)/2+l,即(r-l)/2+l+1

那么结合我们上面的推导,(r-l)/2+l取的是靠左的值,那么(r-l)/2+l+1取的显然是靠右的值

理解了这种角度,就不难理解上面的Claim了

明确了取中间值的方法并避免了可能的非法中间值后,我们就可以开始写代码了~

### 代码如下:

```C++
class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {
        // 预设第一个单词本身就是最长的公共前缀
        int prefix = strs[0].size();
        // 确定两个长度的界
        // 最短前缀长度为0(不存在前缀),最长为第一个字符串的长度
        int l = 0, r = prefix;
        while(l < r) {
            int mid = ((r-l+1)>>1)+l;
            // 第一个字符串的mid长度的子串作为基准
            string bench = strs[0].substr(0, mid);
            bool isprefix = true;
            for(const string& s: strs) {
                for(int j = 0; j < mid; ++j) {
                    if(s[j] != bench[j]) {
                        r = mid-1;
                        isprefix = false;
                        break;
                    }
                }
                if(!isprefix) break;
            }
            if(isprefix) 
                l = mid;
        }
        return strs[0].substr(0, l);
    }
};

```
#### 当然还有另一种避免mid非法取值的方法,同时保持mid取区间靠左的中间值

不过这时mid的定义就会变得很奇怪: mid是最长前缀的最后一个字符的下标

之所以说他奇怪,是因为我们是用两个代表长度的值进行mid的求解,而求出的却是一个下标值,这样前后的定义就不consistent了

这时上面代码中的求字符串切片的语句就应该改成strs[0].substr(0, mid+1);

后面l更新和循环体内部比较字符串的语句也需要修改

总之不推荐这种反直觉的修改方式:

```C++
class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {
        // 预设第一个单词本身就是最长的公共前缀
        int prefix = strs[0].size();
        // 确定两个长度的界
        // 最短前缀长度为0(不存在前缀),最长为第一个字符串的长度
        int l = 0, r = prefix;
        while(l < r) {
            int mid = ((r-l)>>1)+l;
            // 第一个字符串的mid+1长度的子串作为基准
            string bench = strs[0].substr(0, mid+1);
            bool isprefix = true;
            for(const string& s: strs) {
                for(int j = 0; j < mid+1; ++j) {
                    if(s[j] != bench[j]) {
                        r = mid;
                        isprefix = false;
                        break;
                    }
                }
                if(!isprefix) break;
            }
            if(isprefix) 
                l = mid+1;
        }
        return strs[0].substr(0, l);
    }
};
```

不过我们会发现二分法反而会比线性扫描多出很多无用的循环匹配:

优化思路: 或许可以通过类似字符串哈希的方法,再使用数组动态记录所有子串的哈希值来避免多次重复遍历

二分法的最终时间复杂度是O(mnlog(m)), 多出的log(m)是二分第一个字符串的复杂度。
