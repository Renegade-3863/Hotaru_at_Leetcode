## 3 无重复字符的最长子串

### 题目描述如下

> 给定一个字符串s,请你找出其中不含有重复字符的最长子串的长度。

### 解法: 经典滑动窗口O(n)算法
其实涉及到字符串的算法种类并不多,诸如KMP算法,Rabin_Karp字符串编码和类似的字符串哈希算法,不过本题最方便的算法不是上述中的任何一种-它们都是为"字符串匹配"相关的类型题服务的,本题最合适的算法是滑动窗口(一种同样广泛应用在互联网数据链路层的数据可靠传输算法)
### 思路:
定义这样的一个窗口:

[left ... right]

其中所有的字符(包括左右边界的字符)都是不重复的

我们只要将这个窗口在整个字符串上滑动并动态维护它的性质就能最终找到答案

#### 维护方法

使用right指针持续尝试向右拓展窗口右界

对于当前s[right]:

  1. 如果s[right]在[left ... right]里已经出现过了,那么就更新左界left,使得整个窗口不再覆盖s[right]上一次出现的那个位置s[right]',由于窗口是一个连续的区间,这样我们就会自动舍弃掉所有在s[left ... s[right]']范围中的元素,接下来一个常规思路是,可以逐一修改s[left .. s[right]']的记录,将它们标记为没有在窗口中出现过,而一个较为简洁的做法是只修改s[right]'的记录,而在下面没出现的判断条件中稍作调整
  2. 如果s[right]不在[left ... right]里面,那么我们就记录s[right]出现的位置,并继续探查下一个位置,这里判断s[right]没有出现在[left ... right]的条件是: 记录表中没有s[right]对应的表项,即使有表项,其记录的下标也在窗口左界的左侧,这样做判断,1中就不再需要修改s[left .. s[right]'-1]的那些表项了,这是对运行速度极大的一个提升

### 代码实现如下

```C++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        // 用一个散列表记录每个字符上一次出现的位置(默认是不存在的)
        unordered_map<char, int> exist;
        // 定义窗口左右界:初始为只包含第一个字符的窗口
        int left = 0, right = 0;
        int n = s.size();
        // 结果数值,最短的无重复最长子串长度应该是1
        int res = 0;
        // 延申窗口右界
        while(right < n) {
            // 如果当前探查的字符在窗口内没有出现过,那么就更新出现位置并继续下一步探查
            if(exist.find(s[right]) == exist.end() || exist[s[right]] < left) {
                exist[s[right]] = right;
                res = max(right-left+1, res);
            }
            // 否则,说明该字符在当前窗口已经出现过了,要更新左边界以使得更新后的窗口不再覆盖该字符上一次出现的位置
            else {
                left = exist[s[right]]+1;
                // 注意s[right]字符上一次出现的位置也要更新
                exist[s[right]] = right;
            }
            ++right;
        }
        return res;
    }
};
````
