## 7 整数反转
### 题目描述:

> 给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。

> 如果反转后整数超过 32 位的有符号整数的范围 [−2^31,  2^31 − 1] ，就返回 0。

> 假设环境不允许存储 64 位整数（有符号或无符号）。

#### 本题有一个个人以前不太熟悉的C++语言特性:负数的求余结果

#### 一般绝大多数的编程语言(包括C++)都是定义余数的符号与被除数一致的,同时商的绝对值要尽量小

    例如: -4 % 3 = -1 ... -1(余数-1与-4同号,同时商为-1而不是-2)

本题可以利用这个性质进行求余运算

#### 同时还有一个关于32位整型溢出的注意点:

针对题中关于整型溢出的判别条件,有一个很自然的想法是:

假设当前已经反序的数值为res, 剩余部分为rem:

则如果res * 10 + rem % 10 > INT_MAX, 那么就直接返回0

可是这里就会有一个问题,因为CPU在执行这段语句的时候,会优先将res * 10 + rem % 10的结果进行回卷,也就是说,如果res * 10 + rem % 10的结果在数学上确实大于INT_MAX了,那么在计算机上,它的计算结果其实会是res * 10 + rem % 10 - INT_MAX - 1表达式的数学结果,所以这一条件其实是没法正确判断溢出的

那么我们应该怎么判断呢?

### 反向思维:

如果没法直接求出正向结果,那么我们是否可以反向利用期望结果呢?

既然没法表示大于INT_MAX的结果,那么我们可以尝试用不大于INT_MAX的结果来表示溢出情况:

#### Claim:

如果 res > (INT_MAX - rem % 10) / 10

那么就发生了整型正溢出

想法很简单,把原先会造成溢出的罪魁祸首:res * 10的10挪到右边变成除法,一切溢出问题就都解决了

### 还剩最后一个问题:

    这个式子是否是正负数通用的?

就是, 如果原数x是负数,我们是否可以通过同一个式子,仅将INT_MAX变成INT_MIN,同时修改大于号为小于号而不进行其它处理就用这个式子去判别负溢出呢?

#### 具体的:

res < (INT_MIN - rem % 10) / 10

是否可以正确判断整型负溢出?

回到上面的负数除法

这里我们知道rem一定是负数(因为原x是负数,同时我们更改rem的值是通过不断除10这一正数)

那么rem % 10就一定是负数(余数与被除数同号), 同时这个余数的绝对值一定就是rem最低位的值

    举例: -234 % 10 = -23 ... -4

而INT_MIN就是最小可以表示的32位有符号整型,因而这个式子是两个负数相减,那么就一定不会发生溢出, 而它又是下面式子的变体:

res * 10 + rem % 10 < INT_MIN

故这个式子一定也可以判别负溢出

至此,整体逻辑就统一化了:而两个式子用哪一个取决于x的符号,我们只需要加一个布尔类型标记一下x是否为负即可

### 代码如下:

``` C++
class Solution {
public:
    int reverse(int x) {
        int res = 0;
        bool neg = x < 0;
        while(x) {
            if(!neg && res > (INT_MAX - x % 10) / 10)
                return 0;
            if(neg && res < (INT_MIN - x % 10) / 10)
                return 0;
            res = res * 10 + x % 10;
            x /= 10;
        }
        return res;
    }
};
```