## 9 回文数

### 题目描述如下:
> 给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。

> 回文数 是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

> 例如，121 是回文，而 123 不是。

> 负数显然都不是回文: 

> -123 => 321-, 二者不相等

### 两种做法,一种是代码好写,但复杂度较高,另一种是代码稍显复杂,但优化了一半的复杂度(O(n) => O(n/2))

### 直接将原整数反序记录,之后比较和原数是否相同:(当成第7题来做)

    比较简单,这里就不再给出代码了

### 将原整数反转一半,比较两半是否相等(对奇数位数多加一次检查)

给个例子比直接讲思路更清晰:

e.g. 12321 => 左半倒序列: 321, 右半: 21

=> 原数有奇数位: 长的那一侧抛掉最高位: 左半: 21, 右半: 21 => 12321是回文数

#### 注意这里的反转就不用检查溢出了,因为原数一定是有效的有符号32位正整数,而反转的部分甚至位数都是不大于原数的,所以不可能溢出

### 代码如下:

``` C++
class Solution {
public:
    bool isPalindrome(int x) {
        if(x < 0 || (x % 10 == 0 && x != 0)) return false;
        int rev = 0;
        while(rev < x) {
            rev = rev * 10 + x % 10;
            x /= 10;
        }
        return rev == x || rev / 10 == x;
    }
};

```