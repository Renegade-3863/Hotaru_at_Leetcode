## 72 编辑距离

### 题目描述如下:
> 给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数。

> 你可以对一个单词进行如下三种操作：

> 插入一个字符

> 删除一个字符

> 替换一个字符

本体属于非常经典的DP动态规划问题, 不过也涉及到一点小细节的处理问题

DP类问题要首先找最优子结构

对于本题, 结构如下:
- 如果一个原串可以经过最少i步更新到目标串, 那么原串中从头开始比原串短1的子串一定也是经过最少的步骤更新到目标串的从头开始的比目标串短1的子串

- 举个例子方便理解:
> hallo -> fellow

> 如果hall -> fell使用了最少的修改步数, 那么从hall -> fello使用的步数一定也是最少的, 因为如果不是最短步数, 那么我们一定可以找到那个步数更少的策略, 在此基础上再对最后一位进行修改, 这样得到的修改步数就是少于原来的结果的。

- 因此我们可以知道根据当前目标串和原串的最后一个字符是否相等来决定如何递推出结果
- **如果 word1[i-1] == word2[j-1]**, 那么我们可以直接从两个长度短1短结果 dp[i-1][j-1] 得出当前两串的最优编辑距离 dp[i][j]
, 即dp[i][j] = dp[i-1][j]
- **如果 word1[i-1] != word2[j-1]**, 那么此时唯一的不同就是 dp[i][j] = dp[i-1][j-1]+1(需要对最后一个字符进行替换)
- 上述两种情况都需要额外考虑dp[i-1][j]与dp[i][j-1], 因为这两种情况也可以通过一步得出dp[i][j]( dp[i-1][j] 是添加一个字符, dp[i][j-1]是删除一个字符)
- 取三种递推结果的最小值进行更新即可
- dp[m][n] 即为结果
``` C++
class Solution {
public:
    int minDistance(string word1, string word2) {
        int m = word1.size(), n = word2.size();
        // dp[i][j]代表从word1的子串[0,i-1]转化为word2的子串[0, j-1]所需要的最少操作数
        vector<vector<int>> dp(m+1, vector<int>(n+1));
        dp[0][0] = 0;
        for(int i = 1; i <= m; ++i) 
            dp[i][0] = i;
        for(int j = 1; j <= n; ++j)
            dp[0][j] = j;
        for(int i = 1; i <= m; ++i) {
            for(int j = 1; j <= n; ++j) {
                // 如果word1[i-1] == word2[j-1], 那么我们的最短编辑距离是dp[i-1][j-1];
                if(word1[i-1] == word2[j-1])
                    dp[i][j] = min(min(dp[i][j-1], dp[i-1][j]), dp[i-1][j-1]-1) + 1;
                else 
                    dp[i][j] = min(min(dp[i-1][j], dp[i][j-1]), dp[i-1][j-1]) + 1;
            }
        }
        return dp[m][n];
    }
};
```