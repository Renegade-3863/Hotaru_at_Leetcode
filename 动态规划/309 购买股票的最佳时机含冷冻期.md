# 309 买卖股票的最佳时期含冷冻期
### 题目描述如下:
> 给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格。​

> 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

> 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

### 记录一下个人的初次错误尝试:
- 第一次尝试建立DP数组定义:
    - dp[i][0]代表的是共i天, 且第i天我们处在"冷冻期/空"的条件下购买股票的最佳时机可以获取的最大利润
    - dp[i][1]代表的是共i天, 且第i天我们处在"买入"条件下购买股票的最佳时机可以获取的最大利润
    - dp[i][2]代表的是共i天, 且第i天我们处在"卖出"条件下购买股票的最佳时机可以获取的最大利润
    - **更新规则**:
        - dp[i][0] = max(max(dp[i-1][2], dp[i-1][1]), dp[i-1][0]); 
        
            - 即如果第i天在"冷冻期/空"条件下, 则第i-1天可以为"空/冷冻期", "买入", "卖出"中的任意一种状态。对于任意一种情况, 都可以直接一步推导至第i天的结果, 因为"冷冻期/空"代表我们不会对股票做任何操作, 故可以直接继承三者中最大的一个结果作为当前一步的操作
        - dp[i][1] = dp[i-1][0] - prices[i-1];
            - 第i天为"买入"条件, 则第i-1天必须是"冷冻期/空"条件, 而当前状态的最优利润就是前一天的"冷冻期/空"条件利润减去购买股票的价格生成的结果。
        - dp[i][2] = max(dp[i-1][1] + prices[i-1], dp[i-1][0] + prices[i-1]);
            - **原想法(错的)**: 如果第i天在"卖出"条件下, 则第i-1天可以是"冷冻期/空", "买入"中的任意一种, 取其中较大的一个利润值加上prices[i-1]的结果就是最后第i天的最大利润
            - **错误原因**: 要在第i天进行卖出操作, 那么有一个隐含条件是手中必须持有股票, 可是在"空/冷冻期"的利润结果中可能包含已经卖出了股票的情况, 这时不能简单的使用手中不持有股票的情况再卖出股票, 这会导致计算出错误的结果。

### 错误代码:

``` C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        vector<vector<int>> dp(n+1, vector<int>(3, 0));
        // 第一天什么都不做, 类似冷冻期, 利润累计为0
        dp[1][0] = 0;
        // 第一天进行买入操作, 总利润更新为-prices[0]
        dp[1][1] = -prices[0];
        // 第一天不可能进行卖出操作, 默认利润值为0
        dp[1][2] = 0;
        for(int i = 2; i <= n; ++i) {
            // 第i-1天有3三种操作, 对应第i天三种利润状态
            // 第i天在冷冻期
            // 利润状态为从第i-1天买入卖出股票或什么都不做的最大增益值
            // 这里不会有后面dp[i][2]的问题是因为, 第i天在冷冻期, 那么无所谓前一天的状态值手里是否持有股票, 因为不涉及卖出
            dp[i][0] = max(max(dp[i-1][2], dp[i-1][1]), dp[i-1][0]);
            // 第i天在买入状态, 前一天必须在冷静期或者什么也没做的状态
            dp[i][1] = dp[i-1][0] - prices[i-1];
            // 第i天在卖出状态
            // 利润状态为从第i-1天的冷冻期/什么也不做状态或者买入状态卖出当前股票的最大收入
            // 问题: 不能直接用dp[i-1][0] + prices参与计算, 原因在于: 不确定dp[i-1][0]代表的是已经卖出股票的情况, 还是还未卖出股票的情况
            // 故这里会有问题
            // 如何修改? -> 官解: 将状态量修改为关注手上是否有股票, 而不是关注记录前一天的操作这一无用信息
            dp[i][2] = max(dp[i-1][1] + prices[i-1], dp[i-1][0] + prices[i-1]);
        }
        // 返回最后一天三种状态的最大利润
        return max(dp[n][0], dp[n][2]);
    }
};
```

### 如何修改DP定义修正错误?
考虑到上面错误思路的缺失信息, 我们之所以无法正确计算出dp[i][2]的值, 是因为我们无法从前面的已知信息了解到我们手上是否有可以卖出的股票
故我们尝试修改DP定义, 引入**手上是否持有股票**这一信息解释位。

#### 修改后的DP解释如下:
- dp[i][0]代表第i天手上持有股票的情况下最大的利润
- dp[i][1]代表第i天手上不持有股票的情况下最大的利润

#### 这样似乎涵盖了所有情况, 同时也获取了持有股票的信息, 但是有一个问题, 就是我们无法确认当前天的利润结果是否能应用到后一天计算买入的结果 -> 比如前一天的最大利润来自"卖出"操作, 那么后一天我们显然不能再买入股票

#### 故进一步修改DP定义:
- dp[i][0]代表第i天手上持有股票的情况下最大的利润
- dp[i][1]代表第i天手上不持有股票, 并且不处在冷冻期的情况下最大的利润
- dp[i][2]代表第i天手上不持有股票, 并且处长冷冻期的情况下最大的利润

之后进行与上面错误定义中相似的逻辑推理即可得出正确解法

### 正确定义的DP

``` C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.empty()) 
            return 0;
        int n = prices.size();
        // dp[i][0]: 手上持有股票的最大收益
        // dp[i][1]: 手上不持有股票，并且处于冷冻期中的累计最大收益
        // dp[i][2]: 手上不持有股票，并且不在冷冻期中的累计最大收益
        vector<vector<int>> dp(n+1, vector<int>(3, 0));
        dp[1][0] = -prices[0];
        for(int i = 2; i <= n; ++i) {
            dp[i][0] = max(dp[i-1][0], dp[i-1][2] - prices[i-1]);
            dp[i][1] = dp[i-1][0] + prices[i-1];
            dp[i][2] = max(dp[i-1][2], dp[i-1][1]);
        }
        return max(dp[n][1], dp[n][2]);
    }
};
```